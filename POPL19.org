#+TITLE: Theories and Data Structures
#+SUBTITLE: ---Draft---
#+DESCRIPTION: Work done at McMaster University, 2019.
#+AUTHOR: [[mailto:alhassm@mcmaster.ca][Musa Al-hassy]], [[mailto:carette@mcmaster.ca][Jacques Carette]], [[mailto:kahl@cas.mcmaster.ca][Wolfram Kahl]]
#+EMAIL: alhassy@gmail.com
#+EMAIL: carette@mcmaster.ca
#+OPTIONS: toc:nil d:nil
#+PROPERTY: header-args :tangle no :comments link

#+TODO: TODO | STARTED | DONE

# Top level editorial comments.
#+latex_header: \def\edcomm#1#2{ \fbox{\textbf{Comment: #1 }} \emph{#2} \fbox{\textbf{End Comment}}}

# Use:  x vs.{{{null}}} y
# This informs LaTeX not to put the normal space necessary after a period.
#
#+MACRO: null  @@latex:\null{}@@

#+MACRO: edcomm  @@latex:\edcomm{$1}{$2}@@
#
# Warning: {{{edcomm(this, that)}}} cannot contain any commas in ‘this’ nor in ‘that’!

* Preamble :ignore:

# Top level editorial comments.
#+LATEX: \def\edcomm#1#2{ \fbox{\textbf{Comment: #1 }} #2 \fbox{\textbf{End Comment}}}

#+LATEX_HEADER: \usepackage[]{minted}
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize}
# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

#+LATEX_HEADER: \usepackage{multicol}
#+NAME: parallel enviro
#+BEGIN_EXPORT latex
\renewenvironment{parallel}[1][2]
 {
  \setlength{\columnseprule}{2pt}
  \begin{minipage}[t]{\linewidth}
  \begin{multicols}{#1}
 }
 {
 \setlength{\columnseprule}{0pt}
  \end{multicols}
  \end{minipage}
 }
#+END_EXPORT

** LaTeX setup                                                      :ignore:
#+latex_class_options: [acmsmall,review,anonymous]
#+LATEX_CLASS: acmart

#+LATEX_HEADER: \settopmatter{prinfolios=true,princcs=false,printacmref=false}
#+LATEX_HEADER: \usepackage[backend=biber,style=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{MyReferences.bib}

#+LATEX_HEADER: \acmJournal{PACMPL}
#+LATEX_HEADER: \acmVolume{1}
#+LATEX_HEADER: \acmNumber{POPL}
#+LATEX_HEADER: \acmArticle{1}
#+LATEX_HEADER: \acmYear{2020}
#+LATEX_HEADER: \acmMonth{1}
#+LATEX_HEADER: \acmDOI{}
#+LATEX_HEADER: \setcopyright{none}

#+LATEX_HEADER: \usepackage{MyUnicodeSymbols}
#+LATEX_HEADER: \newunicodechar{⨾}{\ensuremath{\mathop{\fatsemi}}}
#+LATEX_HEADER: \newunicodechar{Σ}{\ensuremath{\mathop{\Sigma}}}
#+LATEX_HEADER: \newunicodechar{∘}{\ensuremath{\mathop{\circ}}}
#+LATEX_HEADER: \newunicodechar{Γ}{\ensuremath{\Gamma}}
#+LATEX_HEADER: \newunicodechar{Π}{\ensuremath{\Pi}}
#+LATEX_HEADER: \newunicodechar{⟦}{\ensuremath{\llbracket}}
#+LATEX_HEADER: \newunicodechar{⟧}{\ensuremath{\rrbracket}}
#+LATEX_HEADER: \newunicodechar{Θ}{\ensuremath{\theta}}
#+LATEX_HEADER: \newunicodechar{∎}{\ensuremath{\qedsymbol}}
#+LATEX_HEADER: \newunicodechar{′}{'}
#+LATEX_HEADER: \newunicodechar{τ}{\ensuremath{\tau}}
#+LATEX_HEADER: \newunicodechar{⦃}{\ensuremath{ \{\{ }}  % this is not correct
#+LATEX_HEADER: \newunicodechar{⦄}{\ensuremath{ \}\} }}   % this is not correct
#+LATEX_HEADER: \newunicodechar{⊎}{\ensuremath{\cupdot}}  % should be in myunicode; go #regenerate# it!
#+LATEX_HEADER: \def\with{\kern0.7em \withrule \kern0.7em }
#+LATEX_HEADER: \def\withrule{\vrule height1.57ex depth0.43ex width0.12em}
#+LATEX_HEADER: \newunicodechar{❙}{\ensuremath{\mathop{\with}}}

#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor} % named colours
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \definecolor{darkred}{rgb}{0.3, 0.0, 0.0}
#+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
#+LATEX_HEADER: \definecolor{darkblue}{rgb}{0.0, 0.1, 0.3}
#+LATEX_HEADER: \definecolor{darkorange}{rgb}{1.0, 0.55, 0.0}
#+LATEX_HEADER: \definecolor{sienna}{rgb}{0.53, 0.18, 0.09}
#+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkgreen}

#+NAME: symbols for itemisation environment
#+BEGIN_EXPORT latex
\def\labelitemi{$\diamond$}
\def\labelitemii{$\circ$}
\def\labelitemiii{$\star$}
#+END_EXPORT

# Having small-font code blocks.
# LATEX_HEADER: \RequirePackage{fancyvrb}
# LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}
#+BEGIN_EXPORT latex
\author{Musa Al-hassy}
\affiliation{
  \institution{McMaster University}
  \streetaddress{1280 Main St. W.}
  \city{Hamilton}
  \state{ON}
  \postcode{L8S 4K1}
  \country{Canada}}
\email{alhassym@mcmaster.ca}
\author{Jacques Carette}
\author{Wolfram Kahl}
#+END_EXPORT

** COMMENT acmart Emacs setup
#+NAME: make-acmart-class
#+BEGIN_SRC emacs-lisp :results none
(with-eval-after-load "ox-latex"
   (add-to-list 'org-latex-classes
		'("acmart" "\\documentclass{acmart}"
		  ("\\section{%s}" . "\\section*{%s}")
		  ("\\subsection{%s}" . "\\subsection*{%s}")
		  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
		  ("\\paragraph{%s}" . "\\paragraph*{%s}")
		  ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
* TODO Abstract                                                      :ignore:
:PROPERTIES:
:CUSTOM_ID: abstract
:END:

# Use:  x vs.{{{null}}} ys
# This informs LaTeX not to put the normal space necessary after a period.
#
#+MACRO: null  @@latex:\null{}@@

#+begin_abstract

*placeholder* We give a rational reconstruction of some common (and
not-so-common) data-structures that arise in functional
programming. Our categorical approach also leads us to defining
standard functions which ought to be in all reasonable libraries of
data-structures. Being systematic in the exploration of the design
space reveals quite a lot of structure and information about
data-structures and their origins.

#+begin_center org
#+begin_small
---Source: https://github.com/JacquesCarette/TheoriesAndDataStructures---
#+end_small
#+end_center
#+end_abstract

* STARTED Introduction

It is relatively well-known in functional programming folklore that lists and monoids
are somewhow related. With a little prodding, most functional programmers will recall
(or reconstruct) that lists are, in fact, an instance of a monoid. But when asked if there
is a deeper relation, fewer are able to conjure up ``free
monoid''. Fewer still would be able formally prove this relation, in
other words, to actually fill in all the parts
that make up the adjunction between the forgetful functor from the category of monoids (and
monoid homomorphisms) and the category of types (and functions) and
the free monoid functor. To do so in full detail is, however, quite
informative --- and we will proceed to do so below.
{{{edcomm(MA, It is important to mention that this has been worked out in numerous
other writings. That this is not the prime novelty of the work. E.g.; when
a library claims to support X does it actually provide the necessaity ‘kit’ that
that X /intersincly/ comes with?
)}}}

So as to never be able to cheat, cut corners, etc, we will do all of
our work in Agda, with this document[fn:1]
being literate (and, in fact, written in ultra-literate style via org-mode).
But when we do, something interesting happens: we are forced to write
some rather useful functions over lists. Somehow ~map~,
~_++_~ and ~fold~ are all /required/.

But is this somehow a fluke? Of course not! So, what happens when we
try to explore this relationship?

A programmer's instinct might be to start poking around various
data-structures to try and see which also give rise to a similar
relation. This is a rather difficult task: not all of them arise this
way. Instead, we start from the opposite end: systematically write
down ``simple'' theories, and look at what pops out of the
requirements of having a ``left adjoint to the forgetful
functor''. This turns out to be very fruitful, and the approach we
will take here.

Naturally, we are far from the first to look at this. {{{edcomm(JC, Fill
in the related work here. From Universal Algebra through to many
papers of Hinze, Gibbons, etc)}}}. In other words, the \emph{theory}
behind what we'll be talking about here is well known.

So why bother? Because, in practice, there is just as much beauty in
the details as there was in the theory! By \emph{systematically} going
through simple theories, we will create a dictionary between theories
and a host of useful data-structures. Many of which do not in fact
exist in the standard libraries of common (and uncommon) functional
languages. And even when they do exist, all the ``kit'' that is derived
from the theory is not uniformly provided.

Along the way, we meet several roadblocks, some of which are rather
surprising, as results from the (theory) literature tell us that there
really ought to be no problems there. Only when we dig deeper do we
understand what is going on: classical mathematics is not
constructive! So even when type theorists were busy translating
results for use in functional programming, by not actually proving
their results in a purely constructive meta-theory, they did not
notice these roadblocks. {{{edcomm(MA, Nice!)}}}
Surmounting these problems will highlight how
different axioms, via their \emph{shape}, will naturally give rise to
data-structures easily implementable with inductive types, and which
require much more machinery.

In short, our contributions:
- a systematic exploration of the space of simple theories
- giving a complete dictionary
- highlighting the ``kit'' that arises from fully deriving all the
  adjunctions
- a survey of which languages' standard library offers what structures
  (and what kit)

* TODO Monoids and lists

\edcomm{JC}{Give the full details}

#+BEGIN_SRC haskell
module POPL19 where

open import Helpers.DataProperties

open import Function using (_∘_)
open import Data.Nat
open import Data.Fin  as Fin hiding (_+_)
open import Data.Vec as Vec hiding (map)
open import Relation.Binary.PropositionalEquality
#+END_SRC

* TODO Exploring simple theories
\edcomm{JC}{Not fully sure how to go about this, while staying
leisurely}

* TODO Trouble in paradise
Commutative Monoid, idempotence, and so on.

* TODO Survey of implementations

* TODO We want to be systematic about

+ Exploring Magma-based theories :: see
    https://en.wikipedia.org/wiki/Magma_(algebra)
   where we want to at least explore all the properties that are
   affine.  These are interesting things said at
    https://en.wikipedia.org/wiki/Category_of_magmas which should be
   better understood.

+ Pointed theories ::

   There is not much to be said here. Although I guess 'contractible'
   can be defined already here.

+  Pointed Magma theories ::

   Interestingly, non-associative pointed Magma theories don't show up
   in the nice summary above.
   Of course, this is where Monoid belongs. But it is worth exploring
   all of the combinations too.

+ unary theories ::

   wikipedia sure doesn't spend much time on these (see
   https://en.wikipedia.org/wiki/Algebraic_structure)
   but there are some interesting ones, because if the unary operation
   is 'f' things like
   forall x. f (f x) = x
   is *linear*, because x is used exactly once on each side. The
   non-linearity of 'f' doesn't count (else associativity wouldn't work
   either, as _*_ is used funnily there too).  So "iter 17 f x = x" is a
   fine axiom here too. [iter is definable in the ground theory]

   This is actually where things started, as 'involution' belongs here.

    And is the first weird one.

+ Pointed unary theories :: E.g., the natural numbers

+ Pointer binary theories :: need to figure out which are expressible

+ more :: semiring, near-ring, etc. Need a sampling. But quasigroup
  (with 3 operations!) would be neat to look at.


Also, I think we want to explore
- Free Theories
- Initial Objects
- Cofree Theories (when they exist)

Then the potential 'future work' is huge. But that can be left for
later. We want to have all the above rock solid first.

* TODO Relationship with 700 modules

To make it a POPL paper, as well as related to your module work, it is
also going to be worthwhile to notice and abstract the patterns. Such as
generating induction principles and recursors.

A slow-paced introduction to reflection in Agda: \\
https://github.com/alhassy/gentle-intro-to-reflection

* TODO Timeline

Regarding POPL: \\
https://popl20.sigplan.org/track/POPL-2020-Research-Papers#POPL-2020-Call-for-Papers \\
There is no explicit Pearl category, nor any mention of that style.
Nevertheless, I think it's worth a shot, as I think by being systematic,
we'll "grab" in a lot of things that are not usually considered part of
one's basic toolkit.

However, to have a chance, the technical content of the paper should be
done by June 17th, and the rest of the time should be spent on the
presentation of the material.  The bar is very high at POPL.

* TODO Task list items below
+ [X] JC start learning about org mode

+ [X] JC Figure out how to expand collapsed entries

+ [ ] JC See §4, first code block, of https://alhassy.github.io/init/ to setup ~:ignore:~ correctly on your machine.
      - This may require you to look at sections 2.1 and 2.2.

      This also shows you how to get ‘minted’ colouring.

+ [ ] JC Write introduction/outline

+ [ ] MA To read:
  /From monoids to near-semirings: the essence of MonadPlus and Alternative/,
     https://usuarios.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf.

* DONE Literate Agda in Org-mode

  JC, for now, use “haskell” labelled src blocks to get basic colouring, and I will demonstrate org-agda
  for you in person, if you like. Alternatively, I can generate coloured org-agda on my machine at the very end.

  + A basic setup for /actually/ doing Agda development within org-mode
    can be found at: https://alhassy.github.io/literate/

  + Example uses of org-agda include
    - https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html ; also ⋯.org
      * Shallow use of org-agda merely for colouring ;;  Prototype for Package Formers

	+ Source mentions org-agda features that have not been pushed to the org-agda repo.

    - https://alhassy.github.io/PathCat/
      * Large development with categories ;; Graphs are to categories as lists are to monoids
    - https://github.com/alhassy/gentle-intro-to-reflection
      * Medium-sized development wherein Agda is actually coded within org-mode.


* COMMENT Making README.md                                                 :noexport:

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     ,#+OPTIONS: toc:nil

     ,#+HTML: <h1> TheoriesAndDataStructures </h1>

Showing how some simple mathematical theories naturally give rise to some common data-structures.

Attempting to answer the following questions:

+ Why do lists pop-up more frequently to the average programmer than, say, their duals: bags?

+ More simply, why do unit and empty types occur so naturally? What about enumerations/sums and records/products?

+ Why is it that dependent sums and products do not pop-up expicitly to the average programmer? They arise naturally all the time as tuples and as classes.

+ How do we get the usual toolbox of functions and helpful combinators for a particular data type? Are they ``built into'' the type?

+ Is it that the average programmer works in the category of classical Sets,   with functions and propositional equality? Does this result in some ``free constructions'' not easily made computable since mathematicians usually work in the category of Setoids but tend to quotient to arrive in `Sets` ---where quotienting is not computably feasible, in `Sets` at-least; and why is that?

    ")
    (org-mode)
    (org-md-export-to-markdown)
)
#+END_SRC


* Footnotes

[fn:1] Sources available at https://github.com/JacquesCarette/TheoriesAndDataStructures


* COMMENT footer                                                     :ignore:

f7 ∷ make and open pdf
f8 ∷ make readme

(load-file "~/org-agda-mode/org-agda-mode.el")
(load-file "~/org-agda-mode/literate.el")

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# eval: (global-set-key (kbd "<f8>") (lambda () (interactive) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1)))
# eval: (global-set-key (kbd "<f7>") (lambda () (interactive) (org-babel-tangle) (async-shell-command (concat  "open " (org-latex-export-to-pdf) ))))
# End:

* COMMENT README ─ JC & WK

  + ~C-c C-e~ then ~l o~ to produce the PDF from the org file.

    Or simply press ~f7~ if you've allowed the local variables in this file.

  + ~\edcomm{Person}{Comment}~ to make first-class literate comments:

    \edcomm{MA}{Please read this document; \newline thanks}
