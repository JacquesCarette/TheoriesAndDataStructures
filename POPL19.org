#+TITLE: Theories and Data Structures
#+SUBTITLE: ---Draft---
#+DESCRIPTION: Work done at McMaster University, 2019.
#+AUTHOR: [[mailto:alhassm@mcmaster.ca][Musa Al-hassy]], [[mailto:carette@mcmaster.ca][Jacques Carette]], [[mailto:kahl@cas.mcmaster.ca][Wolfram Kahl]]
#+EMAIL: alhassy@gmail.com
#+EMAIL: carette@mcmaster.ca
#+OPTIONS: toc:nil d:nil
#+PROPERTY: header-args :tangle no :comments link

#+TODO: TODO | STARTED OLD  | DONE

# Top level editorial comments.
#+latex_header: \def\edcomm#1#2{ \fbox{\textbf{Comment: #1 }} \emph{#2} \fbox{\textbf{End Comment}}}

# Use:  x vs.{{{null}}} y
# This informs LaTeX not to put the normal space necessary after a period.
#
#+MACRO: null  @@latex:\null{}@@

#+MACRO: edcomm  @@latex:\edcomm{$1}{$2}@@
#
# Warning: {{{edcomm(this, that)}}} cannot contain any commas in ‚Äòthis‚Äô nor in ‚Äòthat‚Äô!

* Preamble :ignore:

# Top level editorial comments.
#+LATEX: \def\edcomm#1#2{ \fbox{\textbf{Comment: #1 }} #2 \fbox{\textbf{End Comment}}}

#+LATEX_HEADER: \usepackage[]{minted}
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize}
# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

#+LATEX_HEADER: \usepackage{multicol}
#+NAME: parallel enviro
#+BEGIN_EXPORT latex
\renewenvironment{parallel}[1][2]
 {
  \setlength{\columnseprule}{2pt}
  \begin{minipage}[t]{\linewidth}
  \begin{multicols}{#1}
 }
 {
 \setlength{\columnseprule}{0pt}
  \end{multicols}
  \end{minipage}
 }
#+END_EXPORT

** LaTeX setup                                                      :ignore:
# latex_class_options: [acmsmall,review,anonymous]
#+LATEX_CLASS: acmart

#+LATEX_HEADER: \settopmatter{prinfolios=true,princcs=false,printacmref=false}
#+LATEX_HEADER: \usepackage[backend=biber,style=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{MyReferences.bib}

#+LATEX_HEADER: \acmJournal{PACMPL}
#+LATEX_HEADER: \acmVolume{1}
#+LATEX_HEADER: \acmNumber{POPL}
#+LATEX_HEADER: \acmArticle{1}
#+LATEX_HEADER: \acmYear{2020}
#+LATEX_HEADER: \acmMonth{1}
#+LATEX_HEADER: \acmDOI{}
#+LATEX_HEADER: \setcopyright{none}

#+LATEX_HEADER: \usepackage{MyUnicodeSymbols}
#+LATEX_HEADER: \newunicodechar{‚®æ}{\ensuremath{\mathop{\fatsemi}}}
#+LATEX_HEADER: \newunicodechar{Œ£}{\ensuremath{\mathop{\Sigma}}}
#+LATEX_HEADER: \newunicodechar{‚àò}{\ensuremath{\mathop{\circ}}}
#+LATEX_HEADER: \newunicodechar{Œì}{\ensuremath{\Gamma}}
#+LATEX_HEADER: \newunicodechar{Œ†}{\ensuremath{\Pi}}
#+LATEX_HEADER: \newunicodechar{‚ü¶}{\ensuremath{\llbracket}}
#+LATEX_HEADER: \newunicodechar{‚üß}{\ensuremath{\rrbracket}}
#+LATEX_HEADER: \newunicodechar{Œò}{\ensuremath{\theta}}
#+LATEX_HEADER: \newunicodechar{‚àé}{\ensuremath{\qedsymbol}}
#+LATEX_HEADER: \newunicodechar{‚Ä≤}{'}
#+LATEX_HEADER: \newunicodechar{œÑ}{\ensuremath{\tau}}
#+LATEX_HEADER: \newunicodechar{‚¶É}{\ensuremath{ \{\{ }}  % this is not correct
#+LATEX_HEADER: \newunicodechar{‚¶Ñ}{\ensuremath{ \}\} }}   % this is not correct
#+LATEX_HEADER: \newunicodechar{‚äé}{\ensuremath{\cupdot}}  % should be in myunicode; go #regenerate# it!
#+LATEX_HEADER: \def\with{\kern0.7em \withrule \kern0.7em }
#+LATEX_HEADER: \def\withrule{\vrule height1.57ex depth0.43ex width0.12em}
#+LATEX_HEADER: \newunicodechar{‚ùô}{\ensuremath{\mathop{\with}}}

#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor} % named colours
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \definecolor{darkred}{rgb}{0.3, 0.0, 0.0}
#+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
#+LATEX_HEADER: \definecolor{darkblue}{rgb}{0.0, 0.1, 0.3}
#+LATEX_HEADER: \definecolor{darkorange}{rgb}{1.0, 0.55, 0.0}
#+LATEX_HEADER: \definecolor{sienna}{rgb}{0.53, 0.18, 0.09}
#+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkgreen}

#+NAME: symbols for itemisation environment
#+BEGIN_EXPORT latex
\def\labelitemi{$\diamond$}
\def\labelitemii{$\circ$}
\def\labelitemiii{$\star$}
#+END_EXPORT

# Having small-font code blocks.
# LATEX_HEADER: \RequirePackage{fancyvrb}
# LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}
#+BEGIN_EXPORT latex
\author{Musa Al-hassy}
\affiliation{
  \institution{McMaster University}
  \streetaddress{1280 Main St. W.}
  \city{Hamilton}
  \state{ON}
  \postcode{L8S 4K1}
  \country{Canada}}
\email{alhassym@mcmaster.ca}
\author{Jacques Carette}
\author{Wolfram Kahl}
#+END_EXPORT

** COMMENT acmart Emacs setup
#+NAME: make-acmart-class
#+BEGIN_SRC emacs-lisp :results none
(with-eval-after-load "ox-latex"
   (add-to-list 'org-latex-classes
        '("acmart" "\\documentclass{acmart}"
          ("\\section{%s}" . "\\section*{%s}")
          ("\\subsection{%s}" . "\\subsection*{%s}")
          ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
          ("\\paragraph{%s}" . "\\paragraph*{%s}")
          ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
* Abstract :ignore:

  #+begin_center
  *Abstract*
  #+end_center
  #+begin_small
  The ubiquitous data structures found in computing are accompanied by a core interface
  for their manipulation. Irrespective of the language, this core interface arises naturally.

  With a bit of elementary mathematics, we demonstrate that this is no accident: Data structures
  provide abstract syntax trees corresponding to meaningful conceptual theories and the coherency of the
  interface is nothing more than the structure abiding by the laws of the theory.
  #+end_small

* Introduction

  Our story begins with abstract syntax trees.

  Programmers write code, which they may want to execute remotely and so they serialise it
  in a coherent format, transmit it, then have it re-interpreted as meaningful code and executed.
  We will demonstrate some concepts in an ambient language, discuss what it means for them to be coherent,
  show that their associated ‚Äòfree‚Äô structures provide a means to serialise them, then demonstrate that
  the proof obligations for ‚Äòfree‚Äô necessitate an interpretation, or compilation, function.

  The essence of our exposition is the adjunction, which requires understanding naturality, functoriality,
  and categories. In section 2, we review these basic concepts to make this work accessible; then we illustrate the process of obtaining data structures from theories by considering adjunctions.
  Section 3 demonstrates this process by obtaining concepts such as for-loops from pointed unary theories
  and section 4 demonstrates how linked-lists and their interface are obtained from the theory of monoids.
  Finally, section 5 concludes by providing a tabulation of a number of theories and their corresponding
  data structures.

  Our exposition will be informal for brevity and accessibility, however the fact that the proof obligations
  /forced/ the common interfaces to arise was due to exploration in mechanising theories in the proof assistant Agda,
  which did not allow us to elide any ‚Äútrivial details‚Äù. The full details of the theories mentioned in section 5
  can be found at: https://github.com/JacquesCarette/TheoriesAndDataStructures

* Compositionality Schemes

  ‚ÄòStepwise refinement‚Äô is the idea that programming beings with the
  empty, or do-nothing, program ~skip~ then new programs ~S ‚®æ T~ are formed
  by sequencing other programs together. Moreover, sequencing is associative
  ---that is, ~(S ‚®æ T) ‚®æ R = S ‚®æ (T ‚®æ R)~--- and so languages, such as C or Python, do not require parentheses.
  This is an instance of a /monoid/, which is a structure that consists of a collection called the ~Carrier~
  and operation ~_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier~ which is associative and has a no-op identity ~Id : Carrier~.

  In strongly typed languages we cannot just sequence arbitrary programs as we would in, say,
  Python, only to obtain an incompatibility error at runtime. Instead, we would like to be able
  to discuss sequencing ‚Äòwell-typed‚Äô programs. This naturally gives rise to /categories/, which
  consist of a collection called ~Objects~ ---the ‚Äòtypes‚Äô of the language--- and for each
  objects ~A, B~ a collection ~A ‚ü∂ B~ of ‚Äú morphisms, programs, from ~A~ to ~B~ ‚Äù
  ---sometimes also denoted ~Hom A B~--- such that compatible morphisms can be composed to yield
  new morphisms by means of an operation ~_‚®æ_ : ‚àÄ{A B C} ‚Üí (A ‚ü∂ B) ‚Üí (B ‚ü∂ C) ‚Üí (A ‚ü∂ C)~
  which is associative and has a no-op identity ~Id : ‚àÄ{A} ‚Üí A ‚ü∂ A~.
  We are using a long arrow ‚Äò‚ü∂‚Äô to refer to morphisms, programs, of a category and
  a short arrow ‚Äò‚Üí‚Äô to refer to usual function typing.

  #+begin_quote
  Slogan 0: Monoids model untyped programming, categories model typed programming.
  #+end_quote

  A common task for a programmer is to make inferences about large data sets.
  One begins with an empty database then aggregates data ---here's a monoid!
  Does it matter /when/ inferences are made? If we have no data, then we should be able
  to make no new, useful, inference. If we have we have two data-sets $x$ and $y$,
  we may aggregate them to produce a new data-set ~x ‚®æ y~ from which we may make an
  inference ~ùë∞(x ‚®æ y)~. If we have multiple people working together, it may be ideal
  to make inferences ~ùë∞ x~ and ~ùë∞ y~ in ‚Äòparallel‚Äô then combine the inferences together
  to obtain a new inference ~ùë∞ x ‚®æ‚Ä≤ ùë∞ y~. Of-course, we would like these different approaches
  to yield the same results, which they may not. In the case they do, we say
  ~ùë∞ : DataSets ‚Üí Inferences~ is a /(homo)morphism/.

  As ‚Äò(homo)morphism‚Äô, the name of structure-preserving operations between monoids, suggests,
  we have a category whose objects consist of monoids! Formally, a morphism of monoids
  ~ùë∞ : M ‚ü∂ N~ is a function ~Carrier M ‚Üí Carrier N~ that sends ~Id M~ to ~Id N~ and
  distributes over composition in ~M~ to obtain composition in ~N~.

  The typed analogue of homomorphism is called a ‚Äòfunctor‚Äô.
  A functor ~F = (F‚ÇÄ, F‚ÇÅ) : ùìí ‚ü∂ ùíü~ between categories is a homomorphism ---in that it must preserve
  the identities and the compositional structure--- and it must also preserve the typing:
  If ~f : A ‚ü∂ B~ in ùíû, then ~F‚ÇÅ f : F‚ÇÄ A ‚ü∂ F‚ÇÄ B~ in ùíü. For example, if ùìí were Haskell
  and ùíû where C, and ~F‚ÇÄ~ was an assignment of Haskell types to C types, then ~F‚ÇÅ~ must
  preserve typing in that the type of a transformed program ~F‚ÇÅ f~ is obtainable from
  the type of the original program ~f~. It is traditional to drop the subscripts and refer
  to ~F‚ÇÄ, F‚ÇÅ~ simply by ~F~ ---contextual inference eliminates any ambiguity.

  Since categories have nebulous objects, functors also act as a means to endow
  objects with structure. For example, pairs of integers are just integers under
  the ‚Äúpairs of‚Äù operation. More formally, let ~Bin‚ÇÄ A = A √ó A = { (x, y) | x, y ‚àà A }~
  and ~Bin‚ÇÅ f (x, y) = (f x, f y)~.
  Since ~Bin‚ÇÅ id (x, y) = (id x, id y) = (x , y) = id (x, y)~
  and ~Bin‚ÇÅ (f ‚®æ g) (x, y) = ( g (f x), g (f y) ) = (Bin‚ÇÅ f ‚®æ Bin g) (x, y)~,
  one easily finds ~Bin = (Bin‚ÇÄ, Bin‚ÇÅ)~ to be a functor that forms pairs.
  The operation of forming pairs in general, for any ~A~ and ~B~,~ is a bifunctor
  denoted ‚Äú√ó‚Äù, with no subscripts as in ~A √ó B~ and ~f √ó g~.
  Likewise, lists of characters are just characters under the ‚Äúlists of‚Äù operation.
  We encourage the reader to formalise the lists functor and check that it, and the pairs functor,
  indeed satisfy the functor laws.

  #+begin_quote
  Slogan 1: Homomorphisms are structure-preserving operations, functors are homomorphisms
  that also preserve typing. Moreover, functors are structure.
  #+end_quote

  Any general programming language worth its name would support a form of polymorphism
  ---the ability to declare a cookie-cutter recipe applicable to a family of different types.
  Monoids no longer provide for such an abstraction ---they have no notion of types, how could they!
  Consider the doubling functions:
  #+BEGIN_SRC haskell
  dupInt : Int ‚Üí Int √ó Int
  dupInt x = (x , x)

  dupChar : Char ‚Üí Char √ó Char
  dupChar c = (c, c)
  #+END_SRC
  We are forced to repeat the definition for each type we are interested in.
  Polymorphic functions remedy this shortcoming by allowing a
  /write once, use many/ approach:
  #+BEGIN_SRC haskell
  {- A natural transformation from the identity functor to the pairing functor -}
  dup : ‚àÄ{A} ‚Üí A ‚Üí A √ó A
  dup a = (a , a)
  #+END_SRC
  When such a function makes /no dependence on A/, we say that it is
  /parametric polymorphic/ and that it comes with an optimisation law
  known as ‚Äònaturality‚Äô: For any operation ~f~ we have ~(f √ó f) ‚àò dup  = dup ‚àò f~.
  Less cryptically, this says that expressions of the form
  ~let (x, y) = dup a; (x‚Ä≤, y‚Ä≤) = (f x, f y) in ‚ãØ~
  may be replaced with the ~let a‚Ä≤ = f a; (x‚Ä≤ , y‚Ä≤) = dup a‚Ä≤ in ‚ãØ~.
  However, polymorphism does not always come in this form; for example,
  languages such as ~C#~ which allow type inspection would allow us to form
  the following polymorphic method which is not natural:
  #+BEGIN_SRC haskell
  first : ‚àÄ{A} ‚Üí A √ó A ‚Üí A
  first {A} (x, y) = if A is Int then 0 else x
  #+END_SRC

  A /natural transformation/ is a family ~Œ∑ : ‚àÄ{A} : F A ‚ü∂ G A~
  of morphisms such that for any $f : A ‚ü∂ B$ we have $F f ‚®æ Œ∑_B = Œ∑_A ‚®æ G f$.
  If one thinks of ~F~ and ~G~ as structures or formats, then ~Œ∑~ is tantamount to uniform restructuring.
  Less cryptically, the constraint says that the ways to ‚Äòrename‚Äô, ‚Äòrelabel‚Äô, ‚Äòtransform‚Äô ~F A~ to ~G B~
  using any ~f~, are identical: We may rename by operating over the F-structure then reorganise using $Œ∑$,
  or reorganise using $Œ∑$ first then rename by operating over the resulting G-structure.

  The reader is encouraged at this point to find an ~f : A ‚Üí B~ showing
  that ~first~ above fails to be a natural transformation.

  #+begin_quote
  Slogan 2: Functors are structures and natural transformations are uniform restructuring schemes.
  #+end_quote

  A program ~A ‚ü∂ B~ can be thought of as the careful manipulation of ~A~-data to yield ~B~-data.
  When ~A~ and ~B~ are different representations of the same data, the operation is invertible.
  Just as categories model typed programming languages, the notion of non-lossy protocols
  is modelled by the concept of /isomorphism/. An isomorphism, denoted ~A ‚âÖ B~,
  is a pair of morphisms ~f : A ‚ü∂ B~ and ~g : B ‚ü∂ A~ that ‚Äúundo‚Äù each other: ~f ‚®æ g = Id = g ‚®æ f~.
  More concretely, this condition becomes:
  \[
  \forall a, b \bullet\qquad f\, a = b \quad\equiv\quad a = g\, b
  \]
  More often than nought, programs ~A ‚ü∂ B~ are not invertible but do have a /best approximate inverse/.
  One writes $f ‚ä£ g$ to indicate this relationship. When there are notions of ‚Äòapproximation‚Äô,
  denoted ‚Äò‚â§‚Äô, the constraint becomes:
  \[
  \forall a, b \bullet\qquad f\, a ‚â§_B b \quad\equiv\quad a ‚â§_A g\, b
  \]
  Strict equalties have been replaced with approximations instead.

  For example, the injection $‚Ñ§ ‚Ü™ ‚Ñù$ and the ~dup~-lication function
  from earlier have no inverse. However, they do have best approximate inverses:
  \begin{align*}
     & ‚åàr‚åâ ‚â§_‚Ñ§ n \quad\equiv\quad r ‚â§_‚Ñù n
  \\ & x ‚Üë y ‚â§_‚Ñù z \quad\equiv\quad (x, y) ‚â§_{‚Ñù √ó ‚Ñù} \mathsf{dup}\, z
  \\ & p ‚àß q ‚áí r \quad\equiv\quad (p ‚áí r) ‚àß (q ‚áí r) \text{ i.e., } (p, q) ‚áí_{ùîπ √ó ùîπ} \mathsf{dup}\, r
  \end{align*}

  + The ceiling $‚åàr‚åâ$ of a number is the largest /whole/ number that is approximated by $r$:
    0. It is a whole number, $‚åà\_{}‚åâ : ‚Ñù ‚Üí ‚Ñ§$.
    1. It is approximated by $r$: Taking $n ‚âî ‚åàr‚åâ$ in the characterisation yields
      $r ‚â§ ‚åàr‚åâ$.
    2. If $r$ approximates another number, say $n$, then $‚åàr‚åâ$ approximates it too!
       This is just the ‚Äò‚áê‚Äô reading of the characterisation.
  + The maximum x‚Üëy is the largest /single/ number that is approximated by both /x/ and /y/.
  + The conjunction $p ‚àß q$ is the largest /single/ Boolean approximating both Booleans $p$ and $q$.

  Generalising on the duplication example, the reader is encouraged to verify $\sup ‚ä£ K$,
  where the constant function $K : ‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)$ takes an element $z$ to the function $(K z) x = z$
  and $\sup : (‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù$ takes a function $f$ to its supremum $\sup f$.

  #+begin_quote
  Slogan 3: For familiar or simple $g$, one can find useful or complex $f$ with ~f ‚ä£ g~.
  #+end_quote

  For two types ~A~ and ~B~, there may be a number of ways that one ‚Äúapproximates‚Äù the other.
  In a category, we may simply say any morphism ~f : A ‚ü∂ B~ witnesses such an approximation.
  With this in-hand, the previous formulation lifts to the categorical setting as follows.
  For functors ~L : ùíû ‚ü∂ ùíü : R~, one says that /L is adjoint to R/, denoted ~L ‚ä£ R~, when
  there is an isomorphism, as follows, natural in ~A, B~.
  \[
  \forall A, B \bullet\qquad L\, A ‚ü∂_ùíü B \quad\equiv\quad A ‚â§_ùíû R\, B
  \]

  This formulation is terse and easily motivated from the simpler setting,
  however for verification purposes it is a bit difficult to work with.
  There is a more ‚Äòlocal‚Äô formulation.

  An /adjunction/ $L ‚ä£ R$ consists of two (not necessarily natural!) transformations
  $Œ∑ : Id ‚Üí RL$ and $Œµ : LR ‚Üí Id$ such that
  \[
  \forall f, g \bullet\qquad f = Œ∑ ‚®æ R\, g \quad\equiv\quad L\, f ‚®æ Œµ = g
  \]
   Recall that we may construe functors $F$ as structure, then
   maps $X ‚Üí F X$ provide ways to produce structured elements and so are
   referred to as /F-algebras/./ In particular, transformations $X ‚Üí F X$ may be
   thought of as injecting or ‚Äúboxing up‚Äù elements with a trivial F-structure
   whereas transformations $F X ‚Üí X$ can be thought of as ‚Äúcompiling down‚Äù
   the structure to obtain a concrete value.

   With such a terminology, the above characterisation reads:
   /Each L-algebra g is uniquely determined ---as an L-map followed by an Œµ-reduction---
   by its restriction to the unit Œ∑./ Later in the setting of monoids and lists,
   this becomes: List homomorphisms are uniquely determined, as a map followed by a
   reduce, by their restriction to the singleton lists.

   It can be shown that the transformations are actually natural.
   As such, a more local formulation of $L ‚ä£ R$ consists of a pair of natural
   transformations $Œ∑ : Id ‚Üí RL$ and $Œµ : LR ‚Üí Id$ such that the ‚Äúzig-zag‚Äù laws
   holds: $Id = Œ∑ ‚®æ RŒµ$ and $Id = LŒ∑ ‚®æ Œµ$. This is the formulation we shall follow
   in the remainder of the exposition.

   The remainder of the exposition moves slogan 3 from primitive types to the
   more complex types that programmers are generally interested in.
   We begin with simple theories, form the forgetful functor $R$, then seek
   to find the free functor $L$. In the process of establishing the adjunction $L ‚ä£ R$
   we are forced to construct the following tool-kit:

   + Type Constructor ::
        We have a type constructor $L$ that furnishes raw types with structure.
   + Map ::
        Functions $A ‚Üí B$ can be lifted to work on L-structures
        yielding maps $L\, A ‚Üí L\, B$. In database/C# settings, this is known as
        ~select~. Moreover, this operation is a homomorphism. In Haskell notation,
     - ~map id = id~
     - ~map (f ‚®æ g) = map f ‚®æ map g~
   + Wrap :: We obtain a way Œ∑ to construe raw data as having ‚Äòsingleton‚Äô structure.
   + Interpreter :: We obtain a way Œµ to (recursively) ‚Äúfold‚Äù over a structured
                    value to obtain a single value.

                    Moreover, the zig-zag laws ensure that forming a singleton
                    then reducing it is a no-op, as expected.

* DynamicalSystems ---Pointed Unary Theories

  A /pointed unary theory/ consists of a type, a default value of that type,
  and an operation on that type. Think of a box with a screen displaying
  the current state and a button that alters the state.
  Since such basic computing automata are an instance of such a theory
  and there is no standard name for the theory's operation, we shall
  refer to the operation as the ‚Äúnext operation‚Äù since it provides a next value
  in the type. Moreover, we may also refer to these theories as ‚Äúdynamical systems‚Äù
  since they mimic automata.

  Nearly any useful data-structure is an instance of this interface.
  As such, two simple examples more than suffice.
  + The naturals numbers ‚Ñï with starting state 0 and next operation
    being the successor function.
  + The automata with state space ~{even, odd}~, starting state ~even~, and next operation
    ~even ‚Ü¶ odd ‚Ü¶ even~. Consequently, the induced finite-state machine,
    ~foldl (const next) start xs~,
    informs us whether a string input ~xs~ has even or odd length.

#+latex: \def\next{\mathsf{next}}

 If we wish to take dynamical systems to be the objects of a category, call it ùíüùíÆ,
 we must form a notion of homomorphism. The obvious thing to do is to say a
 homomorphism $h : X ‚ü∂ Y$
 is a function between the state spaces that preserves the point
 ---i.e., it sends the default point of $X$ to the default point of /Y/---
 and it commutes with the ‚Äònext‚Äô operation: $‚àÄ x ‚Ä¢\; h(\next_X\, x) = \next_Y (h\, x)$.
 It is then a simple exercise to show that the identity function is a homomorphism
 and the functional composition of homomorphisms results in a homomorphism.

 Let $‚Ñõ : ùíüùíÆ ‚Üí ùíÆ‚ÑØùìâ$ be the function that yields the underlying state space of
 a dynamical system. In particular, on objects it ‚Äòforgets‚Äô the default point and the
 next operation, simply yielding a set. On homomorphisms, it forgets the
 structural-preservation proofs and simply yields a function on sets.
 This is our ‚Äúforgetful‚Äù functor.

 How do we form a ‚Äúfree functor‚Äù $‚Ñí : ùíÆ‚ÑØùìâ ‚Üí ùíüùíÆ$?
 We could serialise programs over dynamical systems by simply keeping track of the
 constructors for the default element and the next operation. Then we could interpret,
 execute, or run such a program later provided we have a way dyanmical system in hand.
 Whence, we consider forming /terms/ over dynamical systems:
#+BEGIN_SRC haskell
  {- Dynamic system terms over a variable set A. -}
  data Term (A : Set) where
    {- variables are terms -}
    inject  : A ‚Üí Term A
    {- Function ‚Äúnames‚Äù applied to terms are again terms -}
    default : Term A
    next    : Term A ‚Üí Term A
#+END_SRC
 Let's provide a more informative renaming:
#+BEGIN_SRC haskell
data Possibly (A : Set) where
  never  : Possibly A
  now    : A ‚Üí Possibly A
  later  : Possibly A ‚Üí Possibly A
#+END_SRC
Well that is definitely interesting; it seems we have stumbled upon a modal-like
data-structure. A value of type ~Possibly A~ may ~never~ be obtained, or it can be
obtained ~now x~ or it is deferred to a later time ~later p~.
By traversing such abstract syntax trees and altering elements as one sees them,
we obtain a ~map~ operation that makes this type into a functor, call it ‚Ñí.
Moreover, for each type ~A~ this functor yields a dynamical system
~(Possibly A, never, later)~.

We are nearly done with our analysis of pointed unary theories.
To show that $‚Ñí ‚ä£ ‚Ñõ$, we need embedding and evaluation polymorphic functions.
#+BEGIN_SRC haskell
Œ∑ : ‚àÄ {D} ‚Üí D ‚Üí Possibly (States D)  {- ‚âà  Id D ‚Üí ‚Ñí (‚Ñõ D)  -}
Œ∑ = now

Œµ : ‚àÄ {D} ‚Üí Possibly D ‚Üí States D    {- ‚âà ‚Ñõ (‚Ñí D) ‚Üí Id D -}
Œµ {D} never      =  default D
Œµ {D} (now d)    =  d
Œµ {D} (later pd) =  next D (Œµ pd)
#+END_SRC
Since no type inspection is performed, there are easily shown to be natural
transformation. The zig-zag laws are equally trivial.

The type ~Possibly A~ consists of dynamical system terms /over/ the ‚Äòvariable set‚Äô ~A~.
What if we considered closed terms; i.e., omitting variables altogether.
Then the injection ~now~ can never be invoked and so may be removed; along with
renaming the other constructors we obtain:
#+BEGIN_SRC haskell
data ùí© where
  zero : ùí©
  succ : ùí© ‚Üí ùí©
#+END_SRC
It seems that the natural numbers were not just an instance of dynamical systems
but rather were canonically so: This type contains the minimum to be considered
a dynamical system! There is the carrier state space ùìù, the default ~zero~, and
the next operation ~succ~. Moreover, its relationship to other dynamical systems
is that it is ‚Äúinitial‚Äù: There is a homomorphism from it to any other dynamical system,
as follows.
#+BEGIN_SRC haskell
{- Essentially: succ‚Åø zero ‚Ü¶ next‚Åø(default D) -}
for-loop : ‚àÄ {D} ‚Üí ùí© ‚Üí States D
for-loop {D} zero     =  default D
for-loop {D} (succ n) =  next D (for-loop)
#+END_SRC

Perhaps the last thing we would have expected would have been for the humble C-style
for-loop to appear.

In summary, by looking at the free structures of pointed unary theories we have obtained:
0. the ~Possibly~ data type, which is functorial;
1. ways to serialise programs over dynamical systems and evaluate them;
2. the natural numbers;
3. the for-loop.

* Lists ---Monoidal Theories

  Unsurprising monoids along with monoid homomorphisms also form a category,
  call it ‚Ñ≥‚Ñ¥ùìÉ.

  Let $‚Ñõ : ‚Ñ≥‚Ñ¥ùìÉ ‚ü∂ ùíÆ‚ÑØùìâ$ be the functor that forgets the structure
  ---the composition operator and the no-op element--- to yield a set.
  On morphisms, it forgets the proofs to yield a function on sets.
  This is our forgetful functor.

  As we mentioned earlier, to find the free structure associated with this
  theory we turn to terms over the theory:
#+BEGIN_SRC haskell
{- Monoidal terms over ‚Äòvariables‚Äô A -}
data Term (A : Set) where
  {- Variables are terms -}
  inj  : A ‚Üí Term A
  {- Function ‚Äúnames‚Äù applied to terms are terms. -}
  Id   : Term A
  _‚®æ_  : Term A ‚Üí Term A ‚Üí Term A
#+END_SRC
  The pointed unary setting was lawless, whereas monoids have laws
  stating how the pieces interact: Composition is associative with unit the no-op.
  In particular, ~inj x ‚®æ Id = inj x~  /should/ hold but it does not.
  This issue is the lack of canonicity: There are multiple forms for items that should be identical.

  If we view the monoid laws as rewrite rules, then it suffices to consider
  a type of only normal forms and have arbitrary terms rewrite down to them.
#+BEGIN_SRC haskell
 Id ‚®æ t      ‚Ü¶  t
 s  ; Id     ‚Ü¶  s
 (r ‚®æ s) ‚®æ t  ‚Ü¶  r ‚®æ (s ‚®æ t)
#+END_SRC
 With these rewrites, an arbitrary term reduces to the form
 ~inj x0 ‚®æ (inj x1 ‚®æ (inj x2 ‚®æ (‚ãØ ‚®æ inj xN)))~; this immediately suggests
 the so-called ‚Äúcons lists‚Äù: We force this right-parenthesising by
 having the left be a raw element and the right be a complex element.
#+BEGIN_SRC haskell
data List (A : Set) where
  []  : List A
  _‚à∑_ : A ‚Üí List A ‚Üí List A
#+END_SRC

 Had we use the associativity rule as a rewrite rule
 the other way around, we would have obtained ‚Äúsnoc lists‚Äù, which are lists
 with constant time access to the last element. Hence there are multiple
 /presentations/ of canonical terms, it is enough to pick one and continue with that.
 The composition operator is regained by rewriting down into the canonical form
 ---by discarding units and parenthesising right-wards:
#+BEGIN_SRC haskell
_++_ : ‚àÄ {A} ‚Üí List A ‚Üí List B
[] ++ ys       = ys
(x ‚à∑ xs) ++ ys = x ‚à∑ (xs ++ ys)
#+END_SRC

Walking along the pointers of a linked-list and altering values as we see them
provides the ~map~ operation, which is also known as ~foreach~ loop in Java and imperative languages.
It is easily seen to be functorial and so we have a functor, call it $‚Ñí : ùíÆ‚ÑØùìâ ‚ü∂ ‚Ñ≥‚Ñ¥ùìÉ$.

In order to show that $‚Ñí ‚ä£ ‚Ñõ$, we need to formulate embedding and evaluation polymorphic functions.
#+BEGIN_SRC haskell
wrap : ‚àÄ {M} ‚Üí Carrier M ‚Üí List (Carrier M)
wrap m = m ‚à∑ []

fold : ‚àÄ {M} ‚Üí List (Carrier M) ‚Üí Carrier M
fold {M} []       = Id M
fold {M} (x ‚à∑ xs) = x ‚®æ fold xs where _‚®æ_ = _‚®æ_ M
#+END_SRC

Notice that there is only one closed canonical term:
If we take the variable set ~A~ to be empty, we can never invoke the ~_‚à∑_~ constructor
and so only have the one value ~[]~. If we instead consider the free structure over
a /singleton/ set, taking ~A~ to have one irrelevant value, and renaming, yields the naturals again:
#+BEGIN_SRC haskell
{- ùí© ‚âÖ List ‚ä§ -}
data ùí© : Set where
  zero : ùí©
  succ : ùí© ‚Üí ùí©
#+END_SRC

In summary, by considering the free structure associated with the most ubiquitous form
of composition we obtained:

1. The linked-list data-structures, forwards with cons and backwards with snoc;
2. The ~map~, or ‚Äúforeach‚Äù, looping construct; along with its optimisation laws:
   ~map id = id~ and ~map (f ‚®æ g) = map f ‚®æ map g~;
3. The helpful ~wrap~ function that embeds a type into the assocaited type of lists;
4. The fold recursion scheme, which is essentially looping.
5. The adjunction property is tantamount to:
   List homomorphisms are uniquely determined, as a map followed by a
   reduce, by their restriction to the singleton lists.

All this from the tiny theory of monoids!

* DataStructures ‚ä£ Theories

Our [[https://github.com/JacquesCarette/TheoriesAndDataStructures][repository]] contains many worked out details of how simple theories give rise to
interesting or common data-structures. The previous two sections demonstrated the
general process, when possible, and there is little to be gained by such repetition.
Instead we shall settle for a listing of results followed by remarks about some
theories that gave us unexpected trouble.

+ Two Sorted :: A two sorted theory consists of just two types and nothing more.

                There are two forgetful functors, depending on which sort is kept.
                The free structure is then to keep the current sort and declare the
                new other sort to be empty.

                Interestingly, another way to ‚Äòforget‚Äô the two sorts is to produce
                the Cartesian product, which is a single type. This gives rise to
                the pairing ‚Äú√ó‚Äù functor, whose left adjoint is then the duplication
                functor ---c.f., ~dup~ from earlier. Surprisingly, duplication,
                denote it by Œî, itself has left-adjoint: If we think of ~ŒîA~ as
                ‚Äòforgetting‚Äô we had a single type and instead thinking we have two
                types, then given any two types, the free single type is obtained
                from their disjoint union.

                Whence, ‚äé ‚ä£ Œî ‚ä£ √ó.

                Notable programming combinators:
                - Records from products;
                - Projections and structural maps over products;
                - Enumerations from disjoint sums;
                - injections and structural maps over sums;
                - duplication combinators and optimisation laws
                  from naturality conditions.

+ Relations :: A /heterogenous relation/ is essentially a binary predicate.

               There are at least two forgetful functors to ùíÆ‚ÑØùìâ, depending on whether
               we keep the source or the target of the relation. The free structures
               are, surprisingly, the empty relations.

               Upon further reflection, this is rather reasonable.
               A relation is essentially a graph and if we are given a set of vertices,
               then the smallest graph that contains such a set must be the empty graph
               on that vertex set.

+ Pointed :: A pointed theory consists of a type along with a single elected point.

             These model types with default values, as in the case in C#.

             The forgetful functor is obtained by dropping the point.
             The free structure is obtained by adjoining a type with a new
             formal element, sometimes called ~null~.

             Notable programming combinators:
             + Nullable types;
             + the Maybe monad

+ Unary ::  A unary theory is a type along with a single unary function on it.

            Dropping the function gives us a forgetful functor, whereas the free
            structure gives us a modal-like data-structure:
            #+BEGIN_SRC haskell
            data Eventually (A : Set) where
              now   : A ‚Üí Eventually A
              later : Eventually A ‚Üí Eventually A
            #+END_SRC
            This type appears silently in the form of ~A~ values tagged by natural
            numbers, since ~Eventually A ‚âÖ A √ó ‚Ñï~. It gives us a structure for indicating
            ‚Äúhow many (delayed) steps‚Äù were needed before we obtained a value.

            Notable programming combinators:
            + A novel modal-like type;
            + The evaluator is iteration, ~later‚Åø (now a) ‚Ü¶ f‚Åø a~, along with
              an array of useful utility properties required for the proof obligations.

+ Involutive :: An involutive theory consists of a type along with a unary function ~f~
                on that type such ~f ‚àò f = id~.

                Keeping only the type gives us a forgetful functor.
                The free structure is obtained by tagging elements with Booleans
                ---the involution then becomes negating the Boolean tag.

                Interestingly, there are /two adjunction proofs/ corresponding to
                whether we embed elements by tagging them with ‚Äòtrue‚Äô or with ‚Äòfalse‚Äô.

                Notable programming combinators:
                + The Booleans;
                + Boolean negation to swap the tag;
                + ~map~ that works on the elements, regardless of the tag.

+ Indexed Unary :: An indexed unary theory consists of a sort along with an indexed family
                   of operations on it: There is a type ~Carrier~ and an indexing type ~I~
                   and a family of ‚Äúactions‚Äù ~Op : {i : I} ‚Üí Carrier ‚Üí Carrier~.

                   These model weak forms of automata.

                   Keeping only the carrier set yields a forgetful functor.
                   The free structure on ~A~ is obtained by using ~NonEmptyLists A~ as
                   the carrier and ~A~ as the index set, with list concatenation as the
                   family of operators: For each ~a : A~, we have an action ~a ‚à∑_~.

                   Notable programming combinators:
                   + Fold is a homomorphism from lists from the index set to an indexed
                     unary theory, over the same index set.
                   + Non-empty lists.

+ Magma  :: A magma is just a sort along with a binary operation.

            Dropping the operation yields a forgetful functor.
            The data type of binary trees provides a free structure.

            Notable programming combinators:
            + Binary tree data structure;
            + Recursion schemes over binary trees;
            + Many coherency laws on how the recursion schemes interact with one another.

+ N-ary :: For given natural number $N$, an /N/-ary theory consists of a type along with
           an endo-operation of $N$ arguments.

           Dropping the operation yields a forgetful functor, whereas
           a free structure is obtained by rose trees.

+ Semigroup :: A semigroup consists of a sort and an associative binary operation.

               Keeping only the carrier sort yields a forgetful operation,
               the type of non-empty lists provides a free structure.

               # There is no free functor from mamgmas to semigroups:
               # Non-associative operations do not ‚Äòextend‚Äô to associative ones!
               #

            Notable programming combinators:
            + Non empty lists data structure;
            + Catenation of non-empty lists, along with associativity proof;
            + Recursion schemes;


+ Monoid :: A monoid consists is a semigroup with a point that acts as the operation's unit.
            Keeping only the carrier yields a forgetful operation,
            whereas linked-lists provide a free structure.

+ Bag :: This is a monoid with the additional law that compositional order does not matter.

         Keeping only the carrier yields a forgetful operation,
         but there is no free structure in a constructive setting.

         Viewing the bag axioms as rewrite rules does not yield canonical forms;
         in particular the commutativity axioms provides a rule ~l ‚®æ r ‚Ü¶ r ‚®æ l~ that
         can be applied infinitely often.

In classical, non-constructive settings, bags and other theories admit free constructions:
One simply forms the terms over the theory than quotients by the equivalence relation
induced from the axioms. However, in computing, we want to be able to actually manipulate
particular data-values rather than consider nebulous equivalence classes.
It seems the leap is not that large, with /decidable equality/ in hand, we can form
a free structure for bags ---but we're no longer in ùíÆ‚ÑØùìâ and so no longer in the traditional domain of computing.

* TODO COMMENT OLD Abstract                                          :ignore:
:PROPERTIES:
:CUSTOM_ID: abstract
:END:

# Use:  x vs.{{{null}}} ys
# This informs LaTeX not to put the normal space necessary after a period.
#
#+MACRO: null  @@latex:\null{}@@

#+begin_abstract

*placeholder* We give a rational reconstruction of some common (and
not-so-common) data-structures that arise in functional
programming. Our categorical approach also leads us to defining
standard functions which ought to be in all reasonable libraries of
data-structures. Being systematic in the exploration of the design
space reveals quite a lot of structure and information about
data-structures and their origins.

#+begin_center org
#+begin_small
---Source: https://github.com/JacquesCarette/TheoriesAndDataStructures---
#+end_small
#+end_center
#+end_abstract

* STARTED COMMENT Introduction

It is relatively well-known in functional programming folklore that lists and monoids
are somewhow related. With a little prodding, most functional programmers will recall
(or reconstruct) that lists are, in fact, an instance of a monoid. But when asked if there
is a deeper relation, fewer are able to conjure up ``free
monoid''. Fewer still would be able formally prove this relation, in
other words, to actually fill in all the parts
that make up the adjunction between the forgetful functor from the category of monoids (and
monoid homomorphisms) and the category of types (and functions) and
the free monoid functor. To do so in full detail is, however, quite
informative --- and we will proceed to do so below.
{{{edcomm(MA, It is important to mention that this has been worked out in numerous
other writings. That this is not the prime novelty of the work. E.g.; when
a library claims to support X does it actually provide the necessaity ‚Äòkit‚Äô that
that X /intersincly/ comes with?
)}}}

So as to never be able to cheat, cut corners, etc, we will do all of
our work in Agda, with this document[fn:1]
being literate (and, in fact, written in ultra-literate style via org-mode).
But when we do, something interesting happens: we are forced to write
some rather useful functions over lists. Somehow ~map~,
~_++_~ and ~fold~ are all /required/.

But is this somehow a fluke? Of course not! So, what happens when we
try to explore this relationship?

A programmer's instinct might be to start poking around various
data-structures to try and see which also give rise to a similar
relation. This is a rather difficult task: not all of them arise this
way. Instead, we start from the opposite end: systematically write
down ``simple'' theories, and look at what pops out of the
requirements of having a ``left adjoint to the forgetful
functor''. This turns out to be very fruitful, and the approach we
will take here.

Naturally, we are far from the first to look at this. {{{edcomm(JC, Fill
in the related work here. From Universal Algebra through to many
papers of Hinze, Gibbons, etc)}}}. In other words, the \emph{theory}
behind what we'll be talking about here is well known.

So why bother? Because, in practice, there is just as much beauty in
the details as there was in the theory! By \emph{systematically} going
through simple theories, we will create a dictionary between theories
and a host of useful data-structures. Many of which do not in fact
exist in the standard libraries of common (and uncommon) functional
languages. And even when they do exist, all the ``kit'' that is derived
from the theory is not uniformly provided.

Along the way, we meet several roadblocks, some of which are rather
surprising, as results from the (theory) literature tell us that there
really ought to be no problems there. Only when we dig deeper do we
understand what is going on: classical mathematics is not
constructive! So even when type theorists were busy translating
results for use in functional programming, by not actually proving
their results in a purely constructive meta-theory, they did not
notice these roadblocks. {{{edcomm(MA, Nice!)}}}
Surmounting these problems will highlight how
different axioms, via their \emph{shape}, will naturally give rise to
data-structures easily implementable with inductive types, and which
require much more machinery.

In short, our contributions:
- a systematic exploration of the space of simple theories
- giving a complete dictionary
- highlighting the ``kit'' that arises from fully deriving all the
  adjunctions
- a survey of which languages' standard library offers what structures
  (and what kit)

* TODO COMMENT Monoids and lists

\edcomm{JC}{Give the full details}

#+BEGIN_SRC haskell
module POPL19 where

open import Helpers.DataProperties

open import Function using (_‚àò_)
open import Data.Nat
open import Data.Fin  as Fin hiding (_+_)
open import Data.Vec as Vec hiding (map)
open import Relation.Binary.PropositionalEquality
#+END_SRC

* TODO COMMENT Exploring simple theories
\edcomm{JC}{Not fully sure how to go about this, while staying
leisurely}

* TODO COMMENT Trouble in paradise
Commutative Monoid, idempotence, and so on.

* TODO COMMENT Survey of implementations

* TODO COMMENT We want to be systematic about

+ Exploring Magma-based theories :: see
    https://en.wikipedia.org/wiki/Magma_(algebra)
   where we want to at least explore all the properties that are
   affine.  These are interesting things said at
    https://en.wikipedia.org/wiki/Category_of_magmas which should be
   better understood.

+ Pointed theories ::

   There is not much to be said here. Although I guess 'contractible'
   can be defined already here.

+  Pointed Magma theories ::

   Interestingly, non-associative pointed Magma theories don't show up
   in the nice summary above.
   Of course, this is where Monoid belongs. But it is worth exploring
   all of the combinations too.

+ unary theories ::

   wikipedia sure doesn't spend much time on these (see
   https://en.wikipedia.org/wiki/Algebraic_structure)
   but there are some interesting ones, because if the unary operation
   is 'f' things like
   forall x. f (f x) = x
   is *linear*, because x is used exactly once on each side. The
   non-linearity of 'f' doesn't count (else associativity wouldn't work
   either, as _*_ is used funnily there too).  So "iter 17 f x = x" is a
   fine axiom here too. [iter is definable in the ground theory]

   This is actually where things started, as 'involution' belongs here.

    And is the first weird one.

+ Pointed unary theories :: E.g., the natural numbers

+ Pointer binary theories :: need to figure out which are expressible

+ more :: semiring, near-ring, etc. Need a sampling. But quasigroup
  (with 3 operations!) would be neat to look at.


Also, I think we want to explore
- Free Theories
- Initial Objects
- Cofree Theories (when they exist)

Then the potential 'future work' is huge. But that can be left for
later. We want to have all the above rock solid first.

* TODO COMMENT Relationship with 700 modules

To make it a POPL paper, as well as related to your module work, it is
also going to be worthwhile to notice and abstract the patterns. Such as
generating induction principles and recursors.

A slow-paced introduction to reflection in Agda: \\
https://github.com/alhassy/gentle-intro-to-reflection

* TODO COMMENT Timeline

Regarding POPL: \\
https://popl20.sigplan.org/track/POPL-2020-Research-Papers#POPL-2020-Call-for-Papers \\
There is no explicit Pearl category, nor any mention of that style.
Nevertheless, I think it's worth a shot, as I think by being systematic,
we'll "grab" in a lot of things that are not usually considered part of
one's basic toolkit.

However, to have a chance, the technical content of the paper should be
done by June 17th, and the rest of the time should be spent on the
presentation of the material.  The bar is very high at POPL.

* TODO COMMENT Task list items below
+ [X] JC start learning about org mode

+ [X] JC Figure out how to expand collapsed entries

+ [ ] JC See ¬ß4, first code block, of https://alhassy.github.io/init/ to setup ~:ignore:~ correctly on your machine.
      - This may require you to look at sections 2.1 and 2.2.

      This also shows you how to get ‚Äòminted‚Äô colouring.

+ [ ] JC Write introduction/outline

+ [ ] MA To read:
  /From monoids to near-semirings: the essence of MonadPlus and Alternative/,
     https://usuarios.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf.

* DONE COMMENT Literate Agda in Org-mode

  JC, for now, use ‚Äúhaskell‚Äù labelled src blocks to get basic colouring, and I will demonstrate org-agda
  for you in person, if you like. Alternatively, I can generate coloured org-agda on my machine at the very end.

  + A basic setup for /actually/ doing Agda development within org-mode
    can be found at: https://alhassy.github.io/literate/

  + Example uses of org-agda include
    - https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html ; also ‚ãØ.org
      * Shallow use of org-agda merely for colouring ;;  Prototype for Package Formers

    + Source mentions org-agda features that have not been pushed to the org-agda repo.

    - https://alhassy.github.io/PathCat/
      * Large development with categories ;; Graphs are to categories as lists are to monoids
    - https://github.com/alhassy/gentle-intro-to-reflection
      * Medium-sized development wherein Agda is actually coded within org-mode.

* COMMENT Making README.md                                                 :noexport:

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     ,#+OPTIONS: toc:nil

     ,#+HTML: <h1> TheoriesAndDataStructures </h1>

Showing how some simple mathematical theories naturally give rise to some common data-structures.

Attempting to answer the following questions:

+ Why do lists pop-up more frequently to the average programmer than, say, their duals: bags?

+ More simply, why do unit and empty types occur so naturally? What about enumerations/sums and records/products?

+ Why is it that dependent sums and products do not pop-up expicitly to the average programmer? They arise naturally all the time as tuples and as classes.

+ How do we get the usual toolbox of functions and helpful combinators for a particular data type? Are they ``built into'' the type?

+ Is it that the average programmer works in the category of classical Sets,   with functions and propositional equality? Does this result in some ``free constructions'' not easily made computable since mathematicians usually work in the category of Setoids but tend to quotient to arrive in `Sets` ---where quotienting is not computably feasible, in `Sets` at-least; and why is that?

    ")
    (org-mode)
    (org-md-export-to-markdown)
)
#+END_SRC

* COMMENT Footnotes

[fn:1] Sources available at https://github.com/JacquesCarette/TheoriesAndDataStructures


* COMMENT footer                                                     :ignore:

f7 ‚à∑ make and open pdf
f8 ‚à∑ make readme

(load-file "~/org-agda-mode/org-agda-mode.el")
(load-file "~/org-agda-mode/literate.el")

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# eval: (global-set-key (kbd "<f8>") (lambda () (interactive) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1)))
# eval: (global-set-key (kbd "<f7>") (lambda () (interactive) (org-babel-tangle) (async-shell-command (concat  "open " (org-latex-export-to-pdf) ))))
# End:

* COMMENT README ‚îÄ JC & WK

  + ~C-c C-e~ then ~l o~ to produce the PDF from the org file.

    Or simply press ~f7~ if you've allowed the local variables in this file.

  + ~\edcomm{Person}{Comment}~ to make first-class literate comments:

    \edcomm{MA}{Please read this document; \newline thanks}
