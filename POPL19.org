#+TITLE: Theories and Data Structures
#+SUBTITLE: ---Draft---
#+DESCRIPTION: Work done at McMaster University, 2019.
# AUTHOR: [[mailto:alhassm@mcmaster.ca][Musa Al-hassy]], [[mailto:carette@mcmaster.ca][Jacques Carette]], [[mailto:kahl@cas.mcmaster.ca][Wolfram Kahl]]
#+EMAIL: alhassy@gmail.com
#+EMAIL: carette@mcmaster.ca
#+OPTIONS: toc:nil d:nil
#+PROPERTY: header-args :tangle no :comments link

* Preamble :ignore:

# Top level editorial comments.
#+LATEX: \def\edcomm#1#2{ \fbox{\textbf{Comment: #1 }} #2 \fbox{\textbf{End Comment}}}

#+LATEX_HEADER: \usepackage[]{minted}
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize}
# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

#+LATEX_HEADER: \usepackage{multicol}
#+NAME: parallel enviro
#+BEGIN_EXPORT latex
\renewenvironment{parallel}[1][2]
 {
  \setlength{\columnseprule}{2pt}
  \begin{minipage}[t]{\linewidth}
  \begin{multicols}{#1}
 }
 {
 \setlength{\columnseprule}{0pt}
  \end{multicols}
  \end{minipage}
 }
#+END_EXPORT

** LaTeX setup                                                      :ignore:
#+latex_class_options: [acmsmall,review,anonymous]
#+LATEX_CLASS: acmart

#+LATEX_HEADER: \settopmatter{prinfolios=true,princcs=false,printacmref=false}
#+LATEX_HEADER: \usepackage[backend=biber,style=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{MyReferences.bib}

#+LATEX_HEADER: \acmJournal{PACMPL}
#+LATEX_HEADER: \acmVolume{1}
#+LATEX_HEADER: \acmNumber{POPL}
#+LATEX_HEADER: \acmArticle{1}
#+LATEX_HEADER: \acmYear{2020}
#+LATEX_HEADER: \acmMonth{1}
#+LATEX_HEADER: \acmDOI{}
#+LATEX_HEADER: \setcopyright{none}

#+LATEX_HEADER: \usepackage{MyUnicodeSymbols}
#+LATEX_HEADER: \newunicodechar{⨾}{\ensuremath{\mathop{\fatsemi}}}
#+LATEX_HEADER: \newunicodechar{Σ}{\ensuremath{\mathop{\Sigma}}}
#+LATEX_HEADER: \newunicodechar{∘}{\ensuremath{\mathop{\circ}}}
#+LATEX_HEADER: \newunicodechar{Γ}{\ensuremath{\Gamma}}
#+LATEX_HEADER: \newunicodechar{Π}{\ensuremath{\Pi}}
#+LATEX_HEADER: \newunicodechar{⟦}{\ensuremath{\llbracket}}
#+LATEX_HEADER: \newunicodechar{⟧}{\ensuremath{\rrbracket}}
#+LATEX_HEADER: \newunicodechar{Θ}{\ensuremath{\theta}}
#+LATEX_HEADER: \newunicodechar{∎}{\ensuremath{\qedsymbol}}
#+LATEX_HEADER: \newunicodechar{′}{'}
#+LATEX_HEADER: \newunicodechar{τ}{\ensuremath{\tau}}
#+LATEX_HEADER: \newunicodechar{⦃}{\ensuremath{ \{\{ }}  % this is not correct
#+LATEX_HEADER: \newunicodechar{⦄}{\ensuremath{ \}\} }}   % this is not correct
#+LATEX_HEADER: \newunicodechar{⊎}{\ensuremath{\cupdot}}  % should be in myunicode; go #regenerate# it!
#+LATEX_HEADER: \def\with{\kern0.7em \withrule \kern0.7em }
#+LATEX_HEADER: \def\withrule{\vrule height1.57ex depth0.43ex width0.12em}
#+LATEX_HEADER: \newunicodechar{❙}{\ensuremath{\mathop{\with}}}

#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor} % named colours
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \definecolor{darkred}{rgb}{0.3, 0.0, 0.0}
#+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
#+LATEX_HEADER: \definecolor{darkblue}{rgb}{0.0, 0.1, 0.3}
#+LATEX_HEADER: \definecolor{darkorange}{rgb}{1.0, 0.55, 0.0}
#+LATEX_HEADER: \definecolor{sienna}{rgb}{0.53, 0.18, 0.09}
#+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkgreen}

#+NAME: symbols for itemisation environment
#+BEGIN_EXPORT latex
\def\labelitemi{$\diamond$}
\def\labelitemii{$\circ$}
\def\labelitemiii{$\star$}
#+END_EXPORT

# Having small-font code blocks.
# LATEX_HEADER: \RequirePackage{fancyvrb}
# LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}
#+BEGIN_EXPORT latex
\author{Musa Al-hassy}
\affiliation{
  \institution{McMaster University}
  \streetaddress{1280 Main St. W.}
  \city{Hamilton}
  \state{ON}
  \postcode{L8S 4K1}
  \country{Canada}}
\email{alhassym@mcmaster.ca}
\author{Jacques Carette}
\author{Wolfram Kahl}
#+END_EXPORT

* Abstract :ignore:
:PROPERTIES:
:CUSTOM_ID: abstract
:END:

# Use:  x vs.{{{null}}} ys
# This informs LaTeX not to put the normal space necessary after a period.
#
#+MACRO: null  @@latex:\null{}@@

#+begin_abstract

*placeholder* We give a rational reconstruction of some common (and
not-so-common) data-structures that arise in functional
programming. Our categorical approach also leads us to defining
standard functions which ought to be in all reasonable libraries of
data-structures. Being systematic in the exploration of the design
space reveals quite a lot of structure and information about
data-structures and their origins.

#+begin_center org
#+begin_small
---Source: https://github.com/JacquesCarette/TheoriesAndDataStructures---
#+end_small
#+end_center
#+end_abstract

* Background

  In this section, we introduce our problem and our exposition language, Agda.

#+BEGIN_SRC haskell
module POPL19 where

open import Helpers.DataProperties

open import Function using (_∘_)
open import Data.Nat
open import Data.Fin  as Fin hiding (_+_)
open import Data.Vec as Vec hiding (map)
open import Relation.Binary.PropositionalEquality
#+END_SRC

A /(non-dependently-typed) signature/ is what programmers refer to as an ‘interface’:
It is a collection of ‘sort’, or type, symbols; along with a collection of ‘function’ symbols,
and a collection of ‘relation’ symbols. For our discussion, we are only interested in
single-sorted non-relational signatures, which means there is only one anonoymous sort symbol
and a collection of function symbols. In Agda:
#+BEGIN_SRC haskell
record Signature₀ : Set₁ where
  field
    FuncSymbs : Set
    arity     : FuncSymbs → ℕ
#+END_SRC

In a dependently-typed language, we may simplify this further
since a pair ~A × (A → B)~ corresponds to a /single/ dependent type ~A′ : B → Set~.
#+BEGIN_SRC haskell
record Signature₁ : Set₁ where
  field
    {- “FunSymbs n” denotes the function symbols of arity “n”. -}
    FuncSymbs : (n : ℕ) → Set
#+END_SRC
Of-course a one-field record is silly, so we simplify further:
#+BEGIN_SRC haskell
Signature : Set₁
Signature = ℕ → Set
#+END_SRC

Here is a few examples of signatures:
#
#+begin_parallel org
#+BEGIN_SRC haskell
data Type𝒮 : Signature where

data Unary𝒮 : Signature where
  next : Unary𝒮 1

data Magma𝒮 : Signature where
  _⨾_ : Magma𝒮 2

data Pointed𝒮 : Signature where
  point : Pointed𝒮 0
#+END_SRC
\columnbreak
#+BEGIN_SRC haskell
{- Pointed Magma -}
data Semigroup𝒮 : Signature where
  Id  : Semigroup𝒮 0
  _⨾_ : Semigroup𝒮 2

{- Alias -}
Monoid𝒮 : Signature
Monoid𝒮 = Semigroup𝒮

{- Pointed Unary Magma -}
data Group𝒮 : Signature where
  Id : Group𝒮 0
  _˘ : Group𝒮 1
  _⨾_ : Group𝒮 2
#+END_SRC
#+end_parallel

Just as a signature can be construed as an interface,
an /algebra/ can be thought of as an implementation:
#+BEGIN_SRC haskell
record _Algebra (FuncSymbs : Signature) : Set₁ where
  field
    Carrier : Set
    reify   : ∀ {n : ℕ} (f : FuncSymbs n) → Vec Carrier n → Carrier

open _Algebra

{- syntactic sugar -}
infixl 5 ⟦_⟧_$_
⟦_⟧_$_ : {FuncSymbs : Signature} {n : ℕ} → FuncSymbs n → (𝒜 : FuncSymbs Algebra)
     → Vec (Carrier 𝒜) n → Carrier 𝒜
⟦ f ⟧ 𝒜 $ xs = reify 𝒜 f xs
#+END_SRC

Here are two examples algebra:
#+BEGIN_SRC haskell
numbers : Type𝒮 Algebra
numbers = record { Carrier = ℕ ; reify = λ { () _ } }

additive-ℕ : Semigroup𝒮 Algebra
additive-ℕ = record { Carrier = ℕ
		    ; reify = λ { Id [] → 0; _⨾_ (x ∷ y ∷ []) → x + y}
		    }
#+END_SRC

To define the notion of /free algebra/, we only need the concept of /homomorphism/:
Functions that preserve the interpretations of the function symbols.
#+BEGIN_SRC haskell
record _Homomorphism (FuncSymbs : Signature) (Src Tgt : FuncSymbs Algebra) : Set where
  field
    map          : Carrier Src → Carrier Tgt
    preservation :   ∀ {n : ℕ} {f : FuncSymbs n} {xs : Vec (Carrier Src) n}
		   → map (⟦ f ⟧ Src $ xs) ≡ ⟦ f ⟧ Tgt $ Vec.map map xs

open _Homomorphism

{- Syntactic Sugar -}
_⟨$⟩_ : {𝒮 : Signature} {Src Tgt : 𝒮 Algebra}
      → (𝒮 Homomorphism) Src Tgt → Carrier Src → Carrier Tgt
h ⟨$⟩ xs = map h xs
#+END_SRC

We are now in a position for our prime definition:
One says  /𝒜 is a free 𝒮-algebra for a type G of ‘generators’/
provided ~𝒜~ is an 𝒮-algebra that ‘contains’ ~G~ and every
𝒮-homomorphisms ~𝒜 → ℬ~ correspond to functions ~G → Carrier ℬ~.

#+BEGIN_SRC haskell
record _free-for_ {𝒮 : Signature} (𝒜 : 𝒮 Algebra) (G : Set) : Set₁ where
  field
    embed      : G → Carrier 𝒜
    extend     : {ℬ : 𝒮 Algebra} → (G → Carrier ℬ) → (𝒮 Homomorphism) 𝒜 ℬ
    {- “Homomorphisms are determined by their behaviour on embeded elements.” -}
    uniqueness : {ℬ : 𝒮 Algebra} (H : (𝒮 Homomorphism) 𝒜 ℬ) → H ≡ extend (map H ∘ embed)

  restrict : {ℬ : 𝒮 Algebra} (H : (𝒮 Homomorphism) 𝒜 ℬ) → G → Carrier ℬ
  restrict H g = H ⟨$⟩ embed g
#+END_SRC

This paper aims to solve ~𝒜 free-for G~ where ~𝒜~ is the unknown.

An interface generally comes with a collection of coherence laws enforcing desirable behaviour.
Likewise, we want to speak of “equational algebras”. This requires we speak of “equations”,
which are pairs of “terms”:

#+BEGIN_SRC haskell
data _Term-over_ (𝒮 : Signature) (X : Set) : Set where
  var : X → 𝒮 Term-over X
  _$_ : {n : ℕ} (f : 𝒮 n) → Vec (𝒮 Term-over X) n → 𝒮 Term-over X

{- Example semigroup term -}
x⨾Id⨾y : Semigroup𝒮 Term-over (Fin 2)
x⨾Id⨾y = _⨾_ $ (_⨾_ $ (var 𝓍 ∷ Id $ [] ∷ []) ∷ var 𝓎 ∷ [])
  where 𝓍 = zero ; 𝓎 = suc zero

{- Ever term is a function of its variables -}
arity : {X : Set} {𝒮 : Signature} → 𝒮 Term-over X → ℕ
arity _ = 0
-- arity (var x) = 1
-- arity (f $ xs) = sum (Vec.map arity xs)
-- Fails termination checking.

⟦_⟧t : {X : Set} {𝒮 : Signature} → (t : 𝒮 Term-over X) → (𝒜 : 𝒮 Algebra)
     → Vec (Carrier 𝒜) (arity t) → Carrier 𝒜
⟦ t ⟧t 𝒜 = {!!}

data _Equation-over_ (𝒮 : Signature) (X : Set) : Set where
  _≈_ : (lhs rhs : 𝒮 Term-over X) → 𝒮 Equation-over X

lhs rhs : {𝒮 : Signature} {X : Set} → 𝒮 Equation-over X → 𝒮 Term-over X
lhs (l ≈ r) = l
rhs (l ≈ r) = r

{- Example semigroup axiom -}
sg-assoc : Semigroup𝒮 Equation-over (Fin 3)
sg-assoc =   (_⨾_ $ (𝓍 ∷ (_⨾_ $ (𝓎 ∷ 𝓏 ∷ [])) ∷ []))
	   ≈ (_⨾_ $ ((_⨾_ $ (𝓍 ∷ 𝓎 ∷ [])) ∷ 𝓏 ∷ []))
  where 𝓍 = var zero ; 𝓎 = var (suc zero) ; 𝓏 = var (suc (suc zero))
#+END_SRC

We can now define an equational theory:
#+BEGIN_SRC haskell
record EquationalSpecfication : Set₁ where
  field
    -- Interface
    FuncSymbs : Signature

    -- Constraints, with numbers as variables
    Axioms    : FuncSymbs Equation-over ℕ → Set

open EquationalSpecfication

record _Theory (ℰ : EquationalSpecfication) : Set₁ where
  field
    Carrier′ : Set
    reify′   : ∀ {n : ℕ} (f : FuncSymbs ℰ n) → Vec Carrier′ n → Carrier′

  algebra : (FuncSymbs ℰ) Algebra
  algebra = record { Carrier = Carrier′ ; reify = reify′ }

  field
    satisfy : ∀ {e} {_ : Axioms ℰ e} → ⟦ lhs e ⟧t algebra ≡ ⟦ rhs e ⟧t algebra
#+END_SRC
* COMMENT README ─ JC & WK

  + ~C-c C-e~ then ~l o~ to produce the PDF from the org file.

    Or simply press ~f7~ if you've allowed the local variables in this file.

  + ~\edcomm{Person}{Comment}~ to make first-class literate comments:

    \edcomm{MA}{Please read this document; \newline thanks}

* We want to be systematic about

+ Exploring Magma-based theories :: see
    https://en.wikipedia.org/wiki/Magma_(algebra)
   where we want to at least explore all the properties that are
   affine.  These are interesting things said at
    https://en.wikipedia.org/wiki/Category_of_magmas which should be
   better understood.

+ Pointed theories ::

   There is not much to be said here. Although I guess 'contractible'
   can be defined already here.

+  Pointed Magma theories ::

   Interestingly, non-associative pointed Magma theories don't show up
   in the nice summary above.
   Of course, this is where Monoid belongs. But it is worth exploring
   all of the combinations too.

+ unary theories ::

   wikipedia sure doesn't spend much time on these (see
   https://en.wikipedia.org/wiki/Algebraic_structure)
   but there are some interesting ones, because if the unary operation
   is 'f' things like
   forall x. f (f x) = x
   is *linear*, because x is used exactly once on each side. The
   non-linearity of 'f' doesn't count (else associativity wouldn't work
   either, as _*_ is used funnily there too).  So "iter 17 f x = x" is a
   fine axiom here too. [iter is definable in the ground theory]

   This is actually where things started, as 'involution' belongs here.

    And is the first weird one.

+ Pointed unary theories :: E.g., the natural numbers

+ Pointer binary theories :: need to figure out which are expressible

+ more :: semiring, near-ring, etc. Need a sampling. But quasigroup
  (with 3 operations!) would be neat to look at.


Also, I think we want to explore
- Free Theories
- Initial Objects
- Cofree Theories (when they exist)

Then the potential 'future work' is huge. But that can be left for
later. We want to have all the above rock solid first.

* Relationship with 700 modules

To make it a POPL paper, as well as related to your module work, it is
also going to be worthwhile to notice and abstract the patterns. Such as
generating induction principles and recursors.

A slow-paced introduction to reflection in Agda: \\
https://github.com/alhassy/gentle-intro-to-reflection

* Timeline

Regarding POPL: \\
https://popl20.sigplan.org/track/POPL-2020-Research-Papers#POPL-2020-Call-for-Papers \\
There is no explicit Pearl category, nor any mention of that style.
Nevertheless, I think it's worth a shot, as I think by being systematic,
we'll "grab" in a lot of things that are not usually considered part of
one's basic toolkit.

However, to have a chance, the technical content of the paper should be
done by June 17th, and the rest of the time should be spent on the
presentation of the material.  The bar is very high at POPL.

* COMMENT Making README.md                                                 :noexport:

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     ,#+OPTIONS: toc:nil

     ,#+HTML: <h1> TheoriesAndDataStructures </h1>

Showing how some simple mathematical theories naturally give rise to some common data-structures.

Attempting to answer the following questions:

+ Why do lists pop-up more frequently to the average programmer than, say, their duals: bags?

+ More simply, why do unit and empty types occur so naturally? What about enumerations/sums and records/products?

+ Why is it that dependent sums and products do not pop-up expicitly to the average programmer? They arise naturally all the time as tuples and as classes.

+ How do we get the usual toolbox of functions and helpful combinators for a particular data type? Are they ``built into'' the type?

+ Is it that the average programmer works in the category of classical Sets,   with functions and propositional equality? Does this result in some ``free constructions'' not easily made computable since mathematicians usually work in the category of Setoids but tend to quotient to arrive in `Sets` ---where quotienting is not computably feasible, in `Sets` at-least; and why is that?

    ")
    (org-mode)
    (org-md-export-to-markdown)
)
#+END_SRC

* COMMENT footer                                                     :ignore:

f7 ∷ make and open pdf
f8 ∷ make readme

(load-file "~/org-agda-mode/org-agda-mode.el")
(load-file "~/org-agda-mode/literate.el")

# Local Variables:
# eval: (global-set-key (kbd "<f8>") (lambda () (interactive) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1)))
# eval: (global-set-key (kbd "<f7>") (lambda () (interactive) (org-babel-tangle) (async-shell-command (concat  "open " (org-latex-export-to-pdf) ))))
# End:

* Task list items below
** DONE JC start learning about org mode
** DONE JC Figure out how to expand collapsed entries
** TODO JC Write introduction/outline
** TODO MA To read:
  /From monoids to near-semirings: the essence of MonadPlus and Alternative/,
     https://usuarios.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf.
