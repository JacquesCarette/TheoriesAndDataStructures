\section{Structures.Multiset}

%{{{ Imports
\begin{code}
module Structures.Multiset where

open import Level renaming (zero to lzero; suc to lsuc ; _‚äî_ to _‚äç_) hiding (lift)
open import Relation.Binary using (Setoid; Rel; IsEquivalence)

-- open import Categories.Category   using (Category)
open import Categories.Functor    using (Functor)
open import Categories.Adjunction using (Adjunction)
open import Categories.Agda       using (Setoids)

open import Function.Equality using (Œ† ; _‚ü∂_ ; id ; _‚àò_)

open import Data.List     using (List; []; _++_; _‚à∑_; foldr)  renaming (map to mapL)
open import Data.List.Properties using (map-++-commute; map-id; map-compose)

open import DataProperties hiding (‚ü®_,_‚ü© ; _,_)
open import SetoidEquiv
open import ParComp
open import EqualityCombinators
open import Belongs
open import Structures.CommMonoid renaming (Hom to CMArrow)
\end{code}
%}}}

%{{{ CtrSetoid
\subsection{CtrSetoid}

As will be explained below, the kind of ``container'' ---|ctr|--- used for
building a |Multiset| needs to support a |Setoid|-polymorphic
equivalence relation.
\begin{code}
record IsCtrEquivalence {‚Ñì : Level} (o : Level) (Ctr : Set ‚Ñì ‚Üí Set ‚Ñì)
  : Set (lsuc ‚Ñì ‚äç lsuc o) where
  field
    equiv        : (X : Setoid ‚Ñì o) ‚Üí Rel (Ctr (Setoid.Carrier X)) (o ‚äç ‚Ñì)
    equivIsEquiv : (X : Setoid ‚Ñì o) ‚Üí IsEquivalence (equiv X)

  -- handy dandy syntactic sugar for |k|ontainer equality
  -- |infix -666 equiv|
  -- |syntax equiv X s t  =  s ‚âà‚Çñ t ‚à∂ X|   -- ghost colon
\end{code}

We have a type transformer |ctr| that furnishes setoids with an equivalence relation |equiv|.

\edcomm{MA}{Since there are no `coherencey' constraints, we might as well say that this
|IsCtrEquivalence| is nothing more than a setoid transformer: The object component of an endofunctor
on the category of setoids. Indeed:}

\begin{code}
  ctrSetoid : (X : Setoid ‚Ñì o) ‚Üí Setoid ‚Ñì (‚Ñì ‚äç o)
  ctrSetoid X = record
    { Carrier        =  Ctr (Setoid.Carrier X)
    ; _‚âà_            =  equiv X
    ; isEquivalence  =  equivIsEquiv X
    }
\end{code}
%}}}

%{{{ CommutativeContainer

In the same vein as before, we consider a setoid-polymorphic equivalence relation that
also furnishes a raw type with a commutative monoid structure. That is, we know have
a the object-component of a functor from the category of setoids to the category of
commutative monoids.

\begin{code}
record CommutativeContainer (‚Ñì c : Level) : Set (lsuc ‚Ñì ‚äç lsuc c) where
  open IsCtrEquivalence using (equiv)
  field
    ùíû                    :   Set ‚Ñì ‚Üí Set ‚Ñì
    isCtrEquivalence     :   IsCtrEquivalence c ùíû
    ‚àÖ                    :  {X : Set ‚Ñì} ‚Üí ùíû X
    _‚äï_                  :  {X : Set ‚Ñì} ‚Üí ùíû X ‚Üí ùíû X ‚Üí ùíû X
    isCommutativeMonoid  :  {X : Setoid ‚Ñì c} ‚Üí IsCommutativeMonoid (equiv isCtrEquivalence X) _‚äï_ ‚àÖ

  open IsCtrEquivalence isCtrEquivalence             public

  commMonoid : (X : Setoid ‚Ñì c) ‚Üí CommMonoid (ctrSetoid X)
  commMonoid X = record
    { e              =   ‚àÖ
    ; _*_            =   _‚äï_
    ; isCommMonoid   =   isCommutativeMonoid
    }
\end{code}

%}}}

%{{{ Multiset
\subsection{Multiset}
A ‚Äúmultiset on type X‚Äù is a structure on which one can define
\begin{itemize}
\item a \emph{commutative monoid} structure,
\item implement the concept of \emph{singleton}
\item implement the concept of \emph{fold}; note that the name
is inspired by its implementation in the main model.  Its signature
would have suggested ``extract'', but this would have been
quite misleading.
\end{itemize}

\begin{code}
record Multiset {‚Ñì c : Level} (X : Setoid ‚Ñì c) : Set (lsuc ‚Ñì ‚äç lsuc c) where  
  field
    commutativeContainer : CommutativeContainer ‚Ñì c

  open CommutativeContainer commutativeContainer     public
  open Setoid X using (_‚âà_) renaming (Carrier to X‚ÇÄ)
  open CommMonoid                             
  open CMArrow

  field
    singleton       :  X‚ÇÄ ‚Üí ùíû X‚ÇÄ
    singleton-cong  :  {i j : X‚ÇÄ} ‚Üí i ‚âà j ‚Üí singleton i ‚âà singleton j  ‚à∂ commMonoid X
    fold            :  {Y : Setoid ‚Ñì c} (CMY : CommMonoid Y) ‚Üí CMArrow (commMonoid Y) CMY
    fold-singleton  :  {CM : CommMonoid X} (x : X‚ÇÄ) ‚Üí x ‚âà fold CM ‚ü®$‚ü© (singleton x)
\end{code}

A ‚Äúmultiset homomorphism‚Äù is a way to lift arbitrary (setoid) functions on the carriers
to be homomorphisms on the underlying commutative monoid structure, as well as a few
compatibility laws.

In the classical contexts of sets and set-functions, the constraints take the form:
|{ f x } ‚âà lift f { x }| and |fold (lift f s) ‚âà f (fold s)|. In particular, the |lift| operation
mimics the behaviour of the morphism, or ‚Äúmap‚Äù, portion of a functor.

\begin{code}
record MultisetHom {‚Ñì c : Level} {X Y : Setoid ‚Ñì c} (A : Multiset X) (B : Multiset Y) : Set (lsuc ‚Ñì ‚äç lsuc c) where
  open Multiset {‚Ñì} {c}
  open CommMonoid
  X‚ÇÄ = Setoid.Carrier X
  open Setoid Y using (_‚âà_)

  field
    lift : (X ‚ü∂ Y) ‚Üí CMArrow (commMonoid A X) (commMonoid B Y)

    singleton-commute : (F : X ‚ü∂ Y) {x : X‚ÇÄ} (let open Œ†)
                      ‚Üí singleton B (F ‚ü®$‚ü© x) ‚âà CMArrow.mor (lift F) ‚ü®$‚ü© singleton A x ‚à∂ commMonoid B Y

    fold-commute : {CMX : CommMonoid X} {CMY : CommMonoid Y} (F : CMArrow CMX CMY)
                    (let open CMArrow)
                 ‚Üí {s : ùíû A X‚ÇÄ}
                 ‚Üí fold B CMY ‚ü®$‚ü© (lift (mor F) ‚ü®$‚ü© s)  ‚âà  F ‚ü®$‚ü© (fold A CMX ‚ü®$‚ü© s)
                 
open MultisetHom
\end{code}

And now something somewhat different: to express that we have the right
functoriality properties (and ``zap''), we need to assume that we have
\emph{constructors} of |Multiset| and |MultisetHom|.  With these in hand,
we can then phrase what extra properties must hold.  Because these properties
hold at ``different types'' than the ones for the underlying ones, these
cannot go into the above.
\begin{spec}
record FunctorialMSH {‚Ñì} {o} (MS : (X : Setoid ‚Ñì (‚Ñì ‚äç o)) ‚Üí Multiset X)
    (MSH : (X Y : Setoid ‚Ñì (‚Ñì ‚äç o)) ‚Üí MultisetHom {‚Ñì} {o} {X} {Y} (MS X) (MS Y))
    : Set (lsuc ‚Ñì ‚äç lsuc o) where
  open Multiset using (Ctr; commMonoid; Ctr-equiv; fold; singleton; cong-singleton; LIST-Ctr)
  open Hom using (mor; _‚ü®$‚ü©_)
  open MultisetHom
  field
    id-pres : {X : Setoid ‚Ñì (‚Ñì ‚äç o)} {x : Ctr (MS X) (Setoid.Carrier X)}
      ‚Üí (lift (MSH X X) id) ‚ü®$‚ü© x ‚âà x ‚à∂ commMonoid (MS X)

    ‚àò-pres : {X Y Z : Setoid ‚Ñì (‚Ñì ‚äç o)} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z}
      {x : Ctr (MS X) (Setoid.Carrier X)} ‚Üí
      let gg = lift (MSH Y Z) g in
      let ff = lift (MSH X Y) f in
      mor (lift (MSH X Z) (g ‚àò f)) Œ†.‚ü®$‚ü© x ‚âà gg ‚ü®$‚ü© (ff ‚ü®$‚ü© x) ‚à∂ commMonoid (MS Z)

    resp-‚âà : {A B : Setoid ‚Ñì (‚Ñì ‚äç o)} {F G : A ‚ü∂ B}
      (F‚âàG : {x : Setoid.Carrier A} ‚Üí (Setoid._‚âà_ B (F Œ†.‚ü®$‚ü© x) (G Œ†.‚ü®$‚ü© x))) ‚Üí
      {x : Ctr (MS A) (Setoid.Carrier A)} ‚Üí
      Hom.mor (lift (MSH A B) F) Œ†.‚ü®$‚ü© x ‚âà Hom.mor (lift (MSH A B) G) Œ†.‚ü®$‚ü© x ‚à∂ commMonoid (MS B)

    fold-lift-singleton : {X : Setoid ‚Ñì (‚Ñì ‚äç o)} ‚Üí
      let ms = MS X in
      let Singleton = record { _‚ü®$‚ü©_ = singleton ms ; cong = cong-singleton ms } in
      {l : Ctr ms (Setoid.Carrier X)} ‚Üí
      IsCtrEquivalence.equiv (Ctr-equiv ms) X l
      (fold (MS (LIST-Ctr ms)) (commMonoid ms)
            (Hom.mor (lift (MSH X (LIST-Ctr ms)) Singleton) Œ†.‚ü®$‚ü© l))

\end{spec}
%}}}

%{{{ BuildLeftAdjoint
Given an implementation of a |Multiset| as well as of |MultisetHom| over that,
build a Free Functor which is left adjoint to the forgetful functor.

\begin{spec}
module BuildLeftAdjoint (MS : ‚àÄ {‚Ñì o} (X : Setoid ‚Ñì (‚Ñì ‚äç o)) ‚Üí Multiset X)
  (MSH : ‚àÄ {‚Ñì o} (X Y : Setoid ‚Ñì (‚Ñì ‚äç o)) ‚Üí MultisetHom {‚Ñì} {o} (MS X) (MS {o = o} Y))
  (Func : ‚àÄ {‚Ñì o} ‚Üí FunctorialMSH {‚Ñì} {o} MS MSH ) where

  open Multiset
  open MultisetHom
  open FunctorialMSH

  Free : (‚ÑìO ‚Ñì‚â° : Level) ‚Üí Functor (Setoids ‚ÑìO (‚ÑìO ‚äç ‚Ñì‚â°)) (MonoidCat ‚ÑìO (‚ÑìO ‚äç ‚Ñì‚â°))
  Free ‚ÑìO ‚Ñì‚â° = record
    { F‚ÇÄ = Œª S ‚Üí LIST-Ctr (MS S) , commMonoid (MS S)
    ; F‚ÇÅ = Œª {X} {Y} f ‚Üí record { Hom (lift {o = ‚Ñì‚â°} (MSH X Y) f) }
    ; identity = id-pres Func
    ; homomorphism = ‚àò-pres Func
    ; F-resp-‚â° = resp-‚âà Func
    }

  LeftAdjoint : {‚Ñì o : Level} ‚Üí Adjunction (Free ‚Ñì o) (Forget ‚Ñì (‚Ñì ‚äç o))
  LeftAdjoint = record
    { unit = record { Œ∑ = Œª X ‚Üí record { _‚ü®$‚ü©_ = singleton (MS X)
                                       ; cong = cong-singleton (MS X) }
                    ; commute = Œª {X} {Y} ‚Üí singleton-commute (MSH X Y) }
    ; counit = record
      { Œ∑ = Œª { (X , cm) ‚Üí let M = MS X in
            MkHom (record { _‚ü®$‚ü©_ = fold M cm
                          ; cong = fold-cong M })
                  (fold-empty M {X} {cm}) (fold-+ M {X} {cm}) }
      ; commute = Œª { {X , _} {Y , _} f ‚Üí fold-commute (MSH X Y) f}
      }
    ; zig = fold-lift-singleton Func
    ; zag = Œª { {X , CM} {m} ‚Üí fold-singleton (MS X) m}
    }
    where
      open Multiset
      open CommMonoid
\end{spec}
%}}}

%{{{ An implementation of |Multiset| using lists with Bag equality
\subsection{An implementation of |Multiset| using lists with Bag equality}
\begin{spec}
module ImplementationViaList {‚Ñì o : Level} (X : Setoid ‚Ñì o) where
  open Setoid X hiding (refl) renaming (Carrier to X‚ÇÄ)
  open BagEq X using (‚â°‚Üí‚áî)
  open ElemOfSing X

  open import Algebra using (Monoid)
  open import Data.List using (monoid)
  module ++ = Monoid (monoid (Setoid.Carrier X))
  open Membership X using (elem-of)
  open ConcatTo‚äéS X using (‚äéS‚âÖ++)

  ListMS : Multiset X
  ListMS = record
    { Ctr = List
    ; Ctr-equiv = record
      { equiv = Œª Y ‚Üí let open BagEq Y in _‚áî_
      ; equivIsEquiv = Œª _ ‚Üí record { refl = ‚âÖ-refl ; sym = ‚âÖ-sym ; trans = ‚âÖ-trans }
      }
    ; Ctr-empty  =  Œª _ ‚Üí []
    ; Ctr-append = Œª _ ‚Üí _++_
    ; MSisCommMonoid = record
      { left-unit  =  Œª _ ‚Üí ‚âÖ-refl
      ; right-unit = Œª xs ‚Üí ‚â°‚Üí‚áî (proj‚ÇÇ ++.identity xs)
      ; assoc      =  Œª xs ys zs ‚Üí ‚â°‚Üí‚áî (++.assoc xs ys zs)
      ; comm       =  Œª xs ys ‚Üí
        elem-of (xs ++ ys)         ‚âÖÀò‚ü® ‚äéS‚âÖ++ ‚ü©
        elem-of xs ‚äéS elem-of ys   ‚âÖ‚ü® ‚äéS-comm _ _ ‚ü©
        elem-of ys ‚äéS elem-of xs   ‚âÖ‚ü® ‚äéS‚âÖ++ ‚ü©
        elem-of (ys ++ xs) ‚àé
      ; _‚ü®‚àô‚ü©_ = Œª {x} {y} {z} {w} x‚áîy z‚áîw ‚Üí
         elem-of (x ++ z)          ‚âÖÀò‚ü® ‚äéS‚âÖ++ ‚ü©
         elem-of x ‚äéS elem-of z    ‚âÖ‚ü® x‚áîy ‚äéS‚ÇÅ z‚áîw ‚ü©
         elem-of y ‚äéS elem-of w    ‚âÖ‚ü® ‚äéS‚âÖ++ ‚ü©
         elem-of (y ++ w) ‚àé
      }

    ; singleton = Œª x ‚Üí x ‚à∑ []
    ; cong-singleton = singleton-‚âà
    ; fold = Œª { (MkCommMon e _+_ _) ‚Üí foldr _+_ e }
    ; fold-cong = Œª {_} {CM} ‚Üí fold-permute {CM = CM}
    ; fold-empty = Œª {Y} ‚Üí Setoid.refl Y
    ; fold-+ = Œª {Y} {CM} {lx} {ly} ‚Üí fold-CM-over-++ {Y} {CM} {lx} {ly}
    ; fold-singleton = Œª {CM} m ‚Üí ‚âà.sym CM (IsCommutativeMonoid.right-unit (isCommMonoid CM) m)
    }
    where
      open CommMonoid
      open IsCommutativeMonoid using (left-unit)
      fold-CM-over-++ : {Z : Setoid ‚Ñì o} {cm : CommMonoid Z} {lx ly : List (Setoid.Carrier Z)} ‚Üí
        let F = foldr (_*_ cm) (e cm) in
        F (lx ++ ly) ‚âà‚åä Z ‚åã (_*_ cm (F lx) (F ly))
      fold-CM-over-++ {Z} {MkCommMon e‚ÇÅ _*‚ÇÅ_ isCM‚ÇÅ} {[]} = Setoid.sym Z (left-unit isCM‚ÇÅ _)
      fold-CM-over-++ {Z} {MkCommMon e‚ÇÅ _*‚ÇÅ_ isCM‚ÇÅ} {lx = x ‚à∑ lx} {ly} =
        let F = foldr _*‚ÇÅ_ e‚ÇÅ in begin‚ü® Z ‚ü©
        x *‚ÇÅ F (lx ++ ly)    ‚âà‚ü® refl ‚ü®‚àô‚ü© fold-CM-over-++ {Z} {MkCommMon e‚ÇÅ _*‚ÇÅ_ isCM‚ÇÅ} {lx} ‚ü©
        x *‚ÇÅ (F lx *‚ÇÅ F ly)  ‚âà‚ü® sym-z (assoc x (F lx) (F ly)) ‚ü©
         (x *‚ÇÅ F lx) *‚ÇÅ F ly ‚ñ†
        where
          open IsCommutativeMonoid isCM‚ÇÅ
          open import Relation.Binary.SetoidReasoning renaming (_‚àé to _‚ñ†)
          open Setoid Z renaming (sym to sym-z)
      open Locations
      open Membership using (El)
      open ElemOf[]
      fold-permute : {Z : Setoid ‚Ñì o} {CM : CommMonoid Z} {i j : List (Setoid.Carrier Z)} ‚Üí
        let open BagEq Z in let open CommMonoid CM renaming (_*_ to _+_; e to e‚ÇÅ) in
        i ‚áî j ‚Üí foldr _+_ e‚ÇÅ i ‚âà‚åä Z ‚åã foldr _+_ e‚ÇÅ j
      fold-permute {Z} {CM} {[]} {[]} i‚áîj = Setoid.refl Z
      fold-permute {Z} {CM} {[]} {x ‚à∑ j} i‚áîj =
        ‚ä•-elim (elem-of-[] Z (_‚âÖ_.from i‚áîj Œ†.‚ü®$‚ü© El (here (Setoid.refl Z))))
      fold-permute {Z} {CM} {x ‚à∑ i} {[]} i‚áîj =
        ‚ä•-elim (elem-of-[] Z (_‚âÖ_.to i‚áîj Œ†.‚ü®$‚ü© El (here (Setoid.refl Z))))
      fold-permute {Z} {CM} {x ‚à∑ i} {x‚ÇÅ ‚à∑ j} i‚áîj = {!!}

ListCMHom : ‚àÄ {‚Ñì o} (X Y : Setoid ‚Ñì (‚Ñì ‚äç o))
  ‚Üí MultisetHom {o = o} (ImplementationViaList.ListMS X) (ImplementationViaList.ListMS Y)
ListCMHom {‚Ñì} {o} X Y = record
  { lift = Œª F ‚Üí let g = Œ†._‚ü®$‚ü©_ F in record
    { mor = record
      { _‚ü®$‚ü©_ = mapL g
      ; cong = Œª {xs} {ys} xs‚âàys ‚Üí
        elem-of (mapL g xs)   ‚âÖ‚ü® shift-map F xs ‚ü©
        shifted F xs          ‚âÖ‚ü® shifted-cong F xs‚âàys ‚ü©
        shifted F ys          ‚âÖÀò‚ü® shift-map F ys ‚ü©
        elem-of (mapL g ys) ‚àé
      }
    ; pres-e =
         elem-of []     ‚âÖÀò‚ü® ‚ä•‚ä•‚âÖelem-of-[] ‚ü©
         ‚ä•‚ä•             ‚âÖ‚ü® ‚ä•‚ä•‚âÖelem-of-[] ‚ü©
         (elem-of e‚ÇÅ) ‚àé

      -- in the proof below, *‚ÇÄ and *‚ÇÅ are both ++
    ; pres-* = Œª {x} {y} ‚Üí
      elem-of (mapL g (x *‚ÇÄ y))           ‚âÖ‚ü® ‚â°‚Üí‚áî (map-++-commute g x y) ‚ü©
      elem-of (mapL g x *‚ÇÅ mapL g y) ‚àé
    }
  ; singleton-commute = Œª f {x} ‚Üí ‚âÖ-refl
  ; fold-commute = f-comm
  }
    where
      open ImplementationViaList
      open CommMonoid (Multiset.commMonoid (ListMS X)) renaming (e to e‚ÇÄ; _*_ to _*‚ÇÄ_)
      open CommMonoid (Multiset.commMonoid (ListMS Y)) renaming (e to e‚ÇÅ; _*_ to _*‚ÇÅ_)
      open Membership Y using (elem-of)
      open BagEq Y using (‚â°‚Üí‚áî)
      open ElemOfMap
      open ElemOf[] Y
      f-comm : {W : CommMonoid X} {Z : CommMonoid Y} (f : Hom (X , W) (Y , Z))
        {lx : List (Setoid.Carrier X)} ‚Üí
        Setoid._‚âà_ Y (foldr (CommMonoid._*_ Z) (CommMonoid.e Z) (mapL (Œ†._‚ü®$‚ü©_ (Hom.mor f)) lx))
                     (Hom.mor f Œ†.‚ü®$‚ü© foldr (CommMonoid._*_ W) (CommMonoid.e W) lx)
      f-comm {MkCommMon e _*_ isCommMonoid‚ÇÅ} {MkCommMon e‚ÇÇ _*‚ÇÇ_ isCM‚ÇÇ} f {[]} =
        Setoid.sym Y (Hom.pres-e f)
      f-comm {MkCommMon e _*_ isCommMonoid‚ÇÅ} {MkCommMon e‚ÇÇ _*‚ÇÇ_ isCM‚ÇÇ} f {x ‚à∑ lx} =
        let g = Œ†._‚ü®$‚ü©_ (Hom.mor f) in  begin‚ü® Y ‚ü©
         ((g x) *‚ÇÇ (foldr _*‚ÇÇ_ e‚ÇÇ (mapL g lx)))  ‚âà‚ü® refl ‚ü®‚àô‚ü© f-comm f {lx} ‚ü©
         ((g x) *‚ÇÇ (g (foldr _*_ e lx)))         ‚âà‚ü® sym (Hom.pres-* f) ‚ü©
         (g (x * foldr _*_ e lx)) ‚ñ†
        where
          open Setoid Y
          open import Relation.Binary.SetoidReasoning using (_‚âà‚ü®_‚ü©_; begin‚ü®_‚ü©_) renaming (_‚àé to _‚ñ†)
          open IsCommutativeMonoid isCM‚ÇÇ using (_‚ü®‚àô‚ü©_)

module BuildProperties where
  open ImplementationViaList
  functoriality : {‚Ñì o : Level} ‚Üí FunctorialMSH {‚Ñì} {o} ListMS ListCMHom
  functoriality {‚Ñì} {o} = record
    { id-pres = Œª {X} {x} ‚Üí BagEq.‚â°‚Üí‚áî X (map-id x)
    ; ‚àò-pres = Œª {_} {_} {Z} {f} {g} {x} ‚Üí BagEq.‚â°‚Üí‚áî Z (map-compose x)
    ; resp-‚âà = Œª {A} {B} {F} {G} F‚âàG {l} ‚Üí respect-‚âà {F = F} {G} F‚âàG l
    ; fold-lift-singleton = Œª {X} {l} ‚Üí BagEq.‚â°‚Üí‚áî X (concat-singleton l)
    }
    where
    open Membership
    open Locations using (here; there)
    open Setoid using (Carrier; trans; sym)
    open Multiset using (Ctr; commMonoid)
    respect-‚âà : {A B : Setoid ‚Ñì (o ‚äç ‚Ñì)} {F G : A ‚ü∂ B}
      (F‚âàG : {x : Carrier A} ‚Üí F Œ†.‚ü®$‚ü© x ‚âà‚åä B ‚åã G Œ†.‚ü®$‚ü© x)
      (lst : Ctr (ListMS A) (Carrier A))
      ‚Üí mapL (Œ†._‚ü®$‚ü©_ F) lst ‚âà mapL (Œ†._‚ü®$‚ü©_ G) lst ‚à∂ commMonoid (ListMS B)
    respect-‚âà                 F‚âàG [] = ‚âÖ-refl
    respect-‚âà {A} {B} {F} {G} F‚âàG (x ‚à∑ lst) = record
      { to = record { _‚ü®$‚ü©_ = to-G ; cong = cong-to-G }
      ; from = record { _‚ü®$‚ü©_ = from-G ; cong = cong-from-G }
      ; inverse-of = record { left-inverse-of = left-inv ; right-inverse-of = right-inv } }
        where
          open LocEquiv B
          f = mapL (Œ†._‚ü®$‚ü©_ F)
          g = mapL (Œ†._‚ü®$‚ü©_ G)

          to-G : {l : List (Carrier A)} ‚Üí elements B (f l) ‚Üí elements B (g l)
          to-G {[]} (El ())
          to-G {_ ‚à∑ _} (El (here sm)) = El (here (trans B sm F‚âàG))
          to-G {_ ‚à∑ _} (El (there belongs)) = lift-el B there (to-G (El belongs))

          cong-to-G : {l : List (Carrier A)} {i j : elements B (f l)} ‚Üí belongs i ‚âã belongs j
            ‚Üí belongs (to-G i) ‚âã belongs (to-G j)
          cong-to-G {[]} ()
          cong-to-G {_ ‚à∑ _} (hereEq x‚âàz y‚âàz) = LocEquiv.hereEq (trans B x‚âàz F‚âàG) (trans B y‚âàz F‚âàG)
          cong-to-G {_ ‚à∑ _} (thereEq i‚âãj) = LocEquiv.thereEq (cong-to-G i‚âãj)

          from-G : {l : List (Carrier A)} ‚Üí elements B (g l) ‚Üí elements B (f l)
          from-G {[]} (El ())
          from-G {_ ‚à∑ _} (El (here sm)) = El (here (trans B sm (sym B F‚âàG)))
          from-G {_ ‚à∑ xs} (El (there x‚ÇÅ)) = lift-el B there (from-G (El x‚ÇÅ))

          cong-from-G : {l : List (Carrier A)} {i j : elements B (g l)} ‚Üí belongs i ‚âã belongs j
            ‚Üí belongs (from-G i) ‚âã belongs (from-G j)
          cong-from-G {[]} ()
          cong-from-G {_ ‚à∑ _} (hereEq x‚âàz y‚âàz) = hereEq (trans B x‚âàz (sym B F‚âàG)) (trans B y‚âàz (sym B F‚âàG))
          cong-from-G {_ ‚à∑ _} (thereEq loc‚ÇÅ) = thereEq (cong-from-G loc‚ÇÅ)

          left-inv : {l : List (Carrier A)} (y : elements B (mapL (Œ†._‚ü®$‚ü©_ F) l))
            ‚Üí belongs (from-G (to-G y)) ‚âã belongs y
          left-inv {[]} (El ())
          left-inv {_ ‚à∑ _} (El (here sm)) = hereEq (trans B (trans B sm F‚âàG) (sym B F‚âàG)) sm
          left-inv {_ ‚à∑ _} (El (there belongs‚ÇÅ)) = thereEq (left-inv (El belongs‚ÇÅ))

          right-inv : {l : List (Carrier A)} (y : elements B (mapL (Œ†._‚ü®$‚ü©_ G) l))
            ‚Üí belongs (to-G (from-G y)) ‚âã belongs y
          right-inv {[]} (El ())
          right-inv {_ ‚à∑ _} (El (here sm)) = hereEq (trans B (trans B sm (sym B F‚âàG)) F‚âàG) sm
          right-inv {_ ‚à∑ _} (El (there belongs‚ÇÅ)) = thereEq (right-inv (El belongs‚ÇÅ))
    concat-singleton : {X : Set ‚Ñì} (lst : List X)
      ‚Üí lst ‚â° foldr _++_ [] (mapL (Œª x ‚Üí x ‚à∑ []) lst)
    concat-singleton [] = ‚â°.refl
    concat-singleton (x ‚à∑ lst) = ‚â°.cong (Œª z ‚Üí x ‚à∑ z) (concat-singleton lst)
\end{spec}

Last but not least, build the left adjoint:

\begin{spec}
module FreeCommMonoid = BuildLeftAdjoint ImplementationViaList.ListMS ListCMHom
  BuildProperties.functoriality
\end{spec}
%}}}

% Quick Folding Instructions:
% C-c C-s :: show/unfold region
% C-c C-h :: hide/fold region
% C-c C-w :: whole file fold
% C-c C-o :: whole file unfold
%
% Local Variables:
% folded-file: t
% eval: (fold-set-marks "%{{{ " "%}}}")
% eval: (fold-whole-buffer)
% fold-internal-margins: 0
% end:
