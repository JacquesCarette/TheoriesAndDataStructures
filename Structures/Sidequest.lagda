\section{Structures.Sidequest}

%{{{ Imports
\begin{code}
module Structures.Sidequest where

open import Level renaming (zero to lzero; suc to lsuc ; _‚äî_ to _‚äç_) hiding (lift)
open import Relation.Binary using (Setoid; Rel; IsEquivalence)

-- open import Categories.Category   using (Category)
open import Categories.Functor    using (Functor)
open import Categories.Adjunction using (Adjunction)
open import Categories.Agda       using (Setoids)

open import Function.Equality using (Œ† ; _‚ü∂_ ; _‚àò_)
open import Function using () renaming (id to Id‚ÇÄ ; _‚àò_ to _‚àò‚ÇÄ_)

open import DataProperties hiding (‚ü®_,_‚ü©)
open import ParComp
open import EqualityCombinators
open import Belongs
open import Structures.CommMonoid renaming (Hom to CMArrow)

open import Data.Nat.Properties using (‚â§-steps ; n‚â§1+n ; n‚à∏n‚â°0)

open import Data.List using (monoid)
open import Data.Fin using (from‚Ñï)

open Œ†          using () renaming (_‚ü®$‚ü©_ to _‚ü®$‚ü©‚ÇÄ_)
open CMArrow    using (_‚ü®$‚ü©_ ; mor ; pres-e ; pres-*)
-- open CommMonoid using (eq-in ; isCommMonoid)
\end{code}
%}}}


%{{{ VecEquality
\begin{code}
module VecEquality {‚Ñì c : Level} (ùíÆ : Setoid c ‚Ñì) where

  open import Data.Vec
  open import Data.Nat hiding (fold ; _*_)
  open import Data.Fin hiding (_+_ ; fold ; _‚â§_)

  -- Sequences
  open Setoid ùíÆ
  module ‚âà = Setoid ùíÆ
  Seq = Vec Carrier

  -- `k`omponent-wise equality on sequences ;; MA: Subscript `c` not directly available.
  infix 5 _‚âà‚Çñ_  
  data _‚âà‚Çñ_ : {n : ‚Ñï} ‚Üí Seq n ‚Üí Seq n ‚Üí Set (c ‚äç ‚Ñì) where
    nil  : [] ‚âà‚Çñ []
    cons : {x y : Carrier} {n : ‚Ñï} {xs ys : Seq n} (x‚âày : x ‚âà y) (xs‚âàys : xs ‚âà‚Çñ ys) ‚Üí (x ‚à∑ xs) ‚âà‚Çñ (y ‚à∑ ys)
\end{code}

It is a simple matter to show that this is an equivalence relation.
\begin{code}
  ‚âà‚Çñ-refl : {n : ‚Ñï} {xs : Seq n} ‚Üí xs ‚âà‚Çñ xs
  ‚âà‚Çñ-refl {xs = []    } = nil
  ‚âà‚Çñ-refl {xs = y ‚à∑ ys} = cons ‚âà.refl ‚âà‚Çñ-refl

  ‚âà‚Çñ-sym : {n : ‚Ñï} {xs ys : Seq n} ‚Üí xs ‚âà‚Çñ ys ‚Üí ys ‚âà‚Çñ xs
  ‚âà‚Çñ-sym nil = nil
  ‚âà‚Çñ-sym (cons x‚âày xs‚âàys) = cons (‚âà.sym x‚âày) (‚âà‚Çñ-sym xs‚âàys)

  ‚âà‚Çñ-trans : {n : ‚Ñï} {xs ys zs : Seq n} ‚Üí xs ‚âà‚Çñ ys ‚Üí ys ‚âà‚Çñ zs ‚Üí xs ‚âà‚Çñ zs
  ‚âà‚Çñ-trans nil nil = nil
  ‚âà‚Çñ-trans (cons x‚âày xs‚âàys) (cons y‚âàz ys‚âàzs) = cons (‚âà.trans x‚âày y‚âàz) (‚âà‚Çñ-trans xs‚âàys ys‚âàzs)
\end{code}
%}}}

%{{{ Permutations
\begin{code}
module Permutations {‚Ñì c : Level} (ùíÆ : Setoid c ‚Ñì)
  where

  open VecEquality ùíÆ
  open Setoid ùíÆ
  open import Data.Vec
  open import Data.Nat hiding (fold ; _*_)
  open import Data.Fin hiding (_+_ ; fold ; _‚â§_)  
\end{code}

  %{{{ Permutations datatype, insert, permute ‚óà 
\begin{code}
  data Permutation : ‚Ñï ‚Üí Set where
    nil  : Permutation 0
    cons : {n : ‚Ñï} ‚Üí (p : Fin (suc n)) ‚Üí (ps : Permutation n) ‚Üí Permutation (suc n)

  -- What exactly are the semantics of these things?
  -- Insertions!
  -- See the |permute| operation below.

  -- |insert xs i x ‚âà xs[1‚Ä¶i-1] ++ [x] ++ xs[i ‚Ä¶ len xs]|
  -- ( Note that this is different from |Data.Vec._[_]‚âî_| which updates a positional element. )
  insert : ‚àÄ {n} {a} {A : Set a} ‚Üí Vec A n ‚Üí Fin (1 + n) ‚Üí A ‚Üí Vec A (1 + n)
  insert xs zero a = a ‚à∑ xs
  insert [] (suc ()) a
  insert (x ‚à∑ xs) (suc i) a = x ‚à∑ insert xs i a

  -- Given a permutation, apply it to a vector.
  infix 6 _‚óà_
  _‚óà_ : ‚àÄ {n} {a} {A : Set a} ‚Üí Permutation n ‚Üí Vec A n ‚Üí Vec A n
  nil         ‚óà []       = []
  (cons p ps) ‚óà (x ‚à∑ xs) = insert (ps ‚óà xs) p x

  _‚Ñï‚à∑_ : (n : ‚Ñï) (ps : Permutation n) ‚Üí Permutation (suc n)
  _‚Ñï‚à∑_ = Œª n ps ‚Üí cons (from‚Ñï n) ps
\end{code}
%}}}
  %{{{ Example permutations: Reverse and Identity

\begin{code}
  rotate : {n : ‚Ñï} (i : ‚Ñï) ‚Üí Permutation (i + n)
  rotate {zero}  zero    = nil
  rotate {suc n} zero    = cons zero (rotate 0)
  rotate {n}     (suc i) = cons (from‚Ñï (i + n)) (rotate i)

  test‚ÇÄ : rotate 0 ‚óà (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ []) ‚â° (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ [])
  test‚ÇÄ = ‚â°.refl

  test‚ÇÅ : rotate 1 ‚óà (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ []) ‚â° (2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ 1 ‚à∑ [])
  test‚ÇÅ = ‚â°.refl

  test‚ÇÇ : rotate 2 ‚óà (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ []) ‚â° (3 ‚à∑ 4 ‚à∑ 5 ‚à∑ 2 ‚à∑ 1 ‚à∑ [])
  test‚ÇÇ = ‚â°.refl

  test‚ÇÉ : rotate 3 ‚óà (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ []) ‚â° (4 ‚à∑ 5 ‚à∑ 3 ‚à∑ 2 ‚à∑ 1 ‚à∑ [])
  test‚ÇÉ = ‚â°.refl

  test‚ÇÑ : rotate 4 ‚óà (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ []) ‚â° (5 ‚à∑ 4 ‚à∑ 3 ‚à∑ 2 ‚à∑ 1 ‚à∑ [])
  test‚ÇÑ = ‚â°.refl

  test‚ÇÖ : rotate 5 ‚óà (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ []) ‚â° (5 ‚à∑ 4 ‚à∑ 3 ‚à∑ 2 ‚à∑ 1 ‚à∑ [])
  test‚ÇÖ = ‚â°.refl

  Id : {n : ‚Ñï} ‚Üí Permutation n
  Id = rotate 0
  -- I.e., insertions at position 0 only; since 0 rotations needed.  

  -- rev {n} = rotate n {0} -- we need to use subst to obtain |n + 0 ‚â° n|
  -- A direct implementation is then clearer.
  rev : {n : ‚Ñï} ‚Üí Permutation n
  rev {zero}  = nil
  rev {suc n} = n ‚Ñï‚à∑ rev
\end{code}

\end{code}

%{{{ Attempt at automatically generating coherency proofs

\begin{code}
{-
  Also considered,

  -- rotate : {n : ‚Ñï} (i : Fin n) ‚Üí Permutation (to‚Ñï i + n) 
  -- rotate {suc zero} zero    = cons zero nil
  -- rotate {suc (suc n)} zero = cons zero (rotate zero)
  -- rotate {suc n} (suc i) = cons (from‚Ñï (to‚Ñï i + suc n)) (subst Permutation {!!} (rotate (inject‚ÇÅ i)))
-}  

  rotate‚Çã‚ÇÅ : (n : ‚Ñï) (i : ‚Ñï){{coh : i ‚â§ n}} ‚Üí Permutation (i + n)
  rotate‚Çã‚ÇÅ zero .0 {{z‚â§n}} = nil
  rotate‚Çã‚ÇÅ (suc n) .0 {{z‚â§n}} = cons zero (rotate‚Çã‚ÇÅ n 0 {{z‚â§n}})
  rotate‚Çã‚ÇÅ (suc n) .(suc i) {{s‚â§s {i} coh}} = cons (from‚Ñï (i + suc n)) (rotate‚Çã‚ÇÅ (suc n) i {{‚â§-steps 1 coh}})

  test‚Çã‚ÇÅ : rotate‚Çã‚ÇÅ 5 0 {{ z‚â§n }} ‚óà (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ []) ‚â° (1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ [])
  test‚Çã‚ÇÅ = ‚â°.refl

  -- ToDo: Consider adding this import into the personal umbrella file |DataProperties|.
  open import Relation.Nullary
  open import Relation.Nullary.Decidable

  proveLeq : {m n : ‚Ñï} {pf : True (m Data.Nat.‚â§? n) } ‚Üí m ‚â§ n
  proveLeq {m} {n} {pf} = toWitness {Q = m Data.Nat.‚â§? n} pf

  9‚â§10 : 9 ‚â§ 10
  9‚â§10 = s‚â§s (s‚â§s (s‚â§s (s‚â§s (s‚â§s (s‚â§s (s‚â§s (s‚â§s (s‚â§s z‚â§n)))))))) -- auto

  99‚â§100 : 99 ‚â§ 100  -- remove final 0 to see err msg
  99‚â§100 = proveLeq                                       -- succinct.

  open import Data.Unit using (tt)

  -- rotate‚ÇÅ : {n : ‚Ñï} {i : ‚Ñï} ‚Üí Permutation (i + n)
  -- rotate‚ÇÅ {n} {i} = rotate‚Çã‚ÇÅ n i {{ proveLeq {i} {n} {{! Agda, why hath thou forsaken me!}} }}
\end{code}

%}}}

%}}}

The following is inspired by copumkin & vmchale's libraries.

  %{{{ Relationship between Vec and Permutation
\begin{code}
  -- Notice that |Permutation n| is similar to, but distinct from, |Vec (Fin (suck n)) n|.
  -- More accurately, as in the traditional sense of the concept,
  -- |Permutation n ‚âÖ (Œ† i : 0..n-1 ‚Ä¢ Fin (n ‚à∏ i))|; cf |_at_| below.
  toVec : {n : ‚Ñï} ‚Üí Permutation n ‚Üí Vec ‚Ñï n
  toVec nil         = []
  toVec (cons p ps) = to‚Ñï p ‚à∑ toVec ps

  -- ToDo: Consider forming inverse of toVec.

  infixr 6 _at_ _at‚Ä≤_

  _at_ : {n : ‚Ñï} ‚Üí Permutation n ‚Üí (i : Fin n) ‚Üí Fin (n ‚à∏ to‚Ñï i)
  cons p ps at zero   =  p
  cons p ps at suc i  =  ps at i

  at-spec : {n : ‚Ñï} {ps : Permutation n} {i : Fin n} ‚Üí to‚Ñï (ps at i)  ‚â°  lookup i (toVec ps)
  at-spec {.(suc _)} {cons p ps} {zero}  =  ‚â°.refl
  at-spec {.(suc _)} {cons p ps} {suc i} =  at-spec {ps = ps}

  open import Data.Fin.Properties using (inject‚â§-lemma ; to-from ; to‚Ñï-injective)

  _at‚Ä≤_ : {n : ‚Ñï} ‚Üí Permutation n ‚Üí Fin n ‚Üí Fin n
  cons p p‚ÇÅ at‚Ä≤ zero = p
  cons p p‚ÇÅ at‚Ä≤ suc i = inject‚â§ (p‚ÇÅ at‚Ä≤ i) (n‚â§1+n _)

  at‚Ä≤-spec : {n : ‚Ñï} {ps : Permutation n} {i : Fin n} ‚Üí to‚Ñï (ps at‚Ä≤ i)  ‚â° lookup i (toVec ps)
  at‚Ä≤-spec {.(suc _)} {cons p ps} {zero} = ‚â°.refl
  at‚Ä≤-spec {.(suc n)} {cons {n} p ps} {suc i}
    rewrite inject‚â§-lemma (ps at‚Ä≤ i) (n‚â§1+n n) = at‚Ä≤-spec {ps = ps}

  -- It is easier to prove certain results with |_at_| rather than |_at‚Ä≤_| due to the
  -- pesky injection. This combinator will hopefully alleviate some troubles.
  -- See |rev-end‚Ä≤| for example usage.
  at-at‚Ä≤ : {n : ‚Ñï} {ps : Permutation n} {i : Fin n} ‚Üí to‚Ñï (ps at i) ‚â°  to‚Ñï (ps at‚Ä≤ i)
  at-at‚Ä≤ {.(suc _)} {cons p ps} {zero} = ‚â°.refl
  at-at‚Ä≤ {.(suc n)} {cons p ps} {suc {n} i}
    rewrite inject‚â§-lemma (ps at‚Ä≤ i) (n‚â§1+n n) =  at-at‚Ä≤ {n} {i = i}

  test-Id : toVec (Id {5}) ‚â° 0 ‚à∑ 0 ‚à∑ 0 ‚à∑ 0 ‚à∑ 0 ‚à∑ []
  test-Id = ‚â°.refl

  Id-spec : {n : ‚Ñï} {j : Fin (suc n)} ‚Üí to‚Ñï (Id {suc n} at j)  ‚â°  0
  Id-spec {n} {zero} = ‚â°.refl
  Id-spec {zero} {suc ()}
  Id-spec {suc n} {suc j} = Id-spec {n} {j}

  rev-spec : {n : ‚Ñï} {i : Fin n} ‚Üí (to‚Ñï (rev {n} at i)) ‚â° n ‚à∏ to‚Ñï (suc i)
  rev-spec {.(suc n)} {zero {n}} = to-from n
  rev-spec {.(suc n)} {suc {n} i} = rev-spec {n} {i}

  test-rev : toVec (rev {5}) ‚â° 4 ‚à∑ 3 ‚à∑ 2 ‚à∑ 1 ‚à∑ 0 ‚à∑ []
  test-rev = ‚â°.refl

  rev-end : {n : ‚Ñï} ‚Üí to‚Ñï (rev {suc n} at from‚Ñï n) ‚â° 0
  rev-end {n} = rev-spec {suc n} {from‚Ñï n} ‚ü®‚â°‚â°‚ü© n-ùìÉ=0
    where n-ùìÉ=0 : n ‚à∏ to‚Ñï (from‚Ñï n) ‚â° 0
          n-ùìÉ=0 rewrite to-from n = n‚à∏n‚â°0 n

  rev-start‚Ä≤ : {n : ‚Ñï} ‚Üí (rev {suc n} at‚Ä≤ zero) ‚â° from‚Ñï n
  rev-start‚Ä≤ {n} = ‚â°.refl

  rev-end‚Ä≤ :  {n : ‚Ñï} ‚Üí rev {suc n} at‚Ä≤ from‚Ñï n ‚â° zero
  rev-end‚Ä≤ {n} = to‚Ñï-injective (‚â°.sym at-at‚Ä≤ ‚ü®‚â°‚â°‚ü© rev-end)
\end{code}
%}}}
  %{{{ Inversion of permutations: deleteP and _Àò
\begin{code}
  -- Deletion for permutations:
  -- [p‚ÇÅ, ‚Ä¶, p‚Çô] ‚îÄ i   ‚Ü¶   [p‚ÇÅ ‚à∏ 1, ‚Ä¶, p·µ¢‚Çã‚ÇÅ ‚à∏ 1, p·µ¢, p·µ¢‚Çä‚ÇÅ, ‚Ä¶, p‚Çô] ?
  _‚îÄ_ : {n : ‚Ñï} ‚Üí Permutation (suc n) ‚Üí Fin (suc n) ‚Üí Permutation n
  cons p ps         ‚îÄ zero              =  ps  -- i.e. delete the zero'th element is essentially ‚Äútail‚Äù
  (cons zero ps)    ‚îÄ (suc {zero} ())
  (cons zero ps)    ‚îÄ (suc {(suc n)} i) = cons zero (ps ‚îÄ i)  -- the suc is dropped, parenthesis move.
  cons (suc p) ps   ‚îÄ suc {zero} ()
  (cons (suc p) ps) ‚îÄ (suc {(suc n)} i) = cons p (ps ‚îÄ i)  -- the suc's ‚Äúcancel‚Äù & mutually associate.

{-
  ‚îÄ-spec : {n : ‚Ñï} {ps : Permutation (suc n)} {i : Fin n} ‚Üí (ps ‚îÄ (suc i)) at i  ‚â°  {!!}
  ‚îÄ-spec {n} {ps} {i} = {!!}
  -- Where is mine hero in shining logical armor?
-}

  open import Relation.Nullary

  -- Permutations come with the obvious involution, but non-trivial implementation
  _Àò : {n : ‚Ñï} ‚Üí Permutation n ‚Üí Permutation n
  _Àò {zero }     nil          = nil
  _Àò {suc n} ps@(cons p ps‚Ä≤) = cons ùìÖ ( (ps ‚îÄ ùíë)Àò )
    where ùìÖ : Fin (suc n)
          ùìÖ = ps at‚Ä≤ p

          ùíë : Fin (suc n)
          ùíë = ps at‚Ä≤ ùìÖ

  test-revÀò : toVec (rev {5} Àò) ‚â° 0 ‚à∑ 0 ‚à∑ 0 ‚à∑ 0 ‚à∑ 0 ‚à∑ []
  test-revÀò = ‚â°.refl
  -- Oh no, this looks bad!
  test-revÀòÀò :  ¬¨  toVec ((rev {5} Àò)Àò) ‚â° toVec (rev {5}) -- It seems this is not an involution!
  test-revÀòÀò ()

  -- |n ‚Ñï‚à∑_| and |_‚îÄ from‚Ñï n| are inverses
  ‚Ñï‚à∑-inverse-‚îÄ : {n : ‚Ñï} ‚Üí n ‚Ñï‚à∑ (rev {suc n} ‚îÄ from‚Ñï n)  ‚â°  rev {suc n}
  ‚Ñï‚à∑-inverse-‚îÄ {zero} = ‚â°.refl
  ‚Ñï‚à∑-inverse-‚îÄ {suc n} = ‚â°.cong (Œª x ‚Üí cons (from‚Ñï (suc n)) x) ‚Ñï‚à∑-inverse-‚îÄ

  test-rev-end : toVec (rev {5} ‚îÄ from‚Ñï 4) ‚â° 3 ‚à∑ 2 ‚à∑ 1 ‚à∑ 0 ‚à∑ [] -- i.e., toVec (rev {4})
  test-rev-end = ‚â°.refl

  rev-end=rev : {n : ‚Ñï}  ‚Üí  rev {suc n} ‚îÄ from‚Ñï n  ‚â°  rev {n}
  rev-end=rev {zero} = ‚â°.refl
  rev-end=rev {suc n} = ‚â°.cong (n ‚Ñï‚à∑_) rev-end=rev

  revÀò=Id : {n : ‚Ñï} ‚Üí rev Àò  ‚â°  Id {n}
  revÀò=Id {zero} = ‚â°.refl
  revÀò=Id {suc n} = ‚â°.cong‚ÇÇ cons rev-end‚Ä≤ it -- ‚â°.cong‚ÇÇ cons rev-end‚Ä≤ goal

    where

      step‚ÇÅ : rev {suc n}  at‚Ä≤ rev {suc n} at‚Ä≤ from‚Ñï n ‚â° (rev {suc n}) at‚Ä≤ zero
      step‚ÇÅ = ‚â°.cong (rev at‚Ä≤_) rev-end‚Ä≤

      step‚ÇÇ : (rev {suc n}) at‚Ä≤ zero  ‚â°  from‚Ñï n
      step‚ÇÇ = rev-start‚Ä≤

      it‚ÇÄ :    (rev {suc n} ‚îÄ (rev {suc n} at‚Ä≤ rev {suc n} at‚Ä≤ from‚Ñï n))  Àò
            ‚â° (rev {n}) Àò
      it‚ÇÄ = ‚â°.cong _Àò (‚â°.cong (rev {suc n} ‚îÄ_) (step‚ÇÅ ‚ü®‚â°‚â°‚ü© step‚ÇÇ)
            ‚ü®‚â°‚â°‚ü© rev-end=rev)

      it : (rev {suc n} ‚îÄ (rev {suc n} at‚Ä≤ rev {suc n} at‚Ä≤ from‚Ñï n))  Àò
            ‚â° Id
      it = it‚ÇÄ ‚ü®‚â°‚â°‚ü© revÀò=Id
\end{code}

\begin{spec}
  -- Extensional Permutation equality
  infix 5 _‚âà‚Çö_
  _‚âà‚Çö_ : {n : ‚Ñï} (ps qs : Permutation n) ‚Üí Set (c ‚äç ‚Ñì)
  _‚âà‚Çö_ {n} ps qs  =  {xs : Seq n} ‚Üí ps ‚óà xs  ‚âà‚Çñ  qs ‚óà xs

  -- This operation is involutionary: It is its own inverse.
  -- ÀòÀò : {n : ‚Ñï} {ps : Permutation n} ‚Üí ps Àò Àò  ‚âà‚Çö  ps
  -- ÀòÀò {zero} {nil} = ‚âà‚Çñ-refl
  -- ÀòÀò {suc n} {cons p ps} {x ‚à∑ xs} = {! FALSE: See test-revÀòÀò!}

  -- The identity permutation is a fixed point.
  IdÀò : {n : ‚Ñï} ‚Üí Id Àò  ‚âà‚Çö  Id {n}
  IdÀò {.0} {[]} = ‚âà‚Çñ-refl
  IdÀò {.(suc _)} {x ‚à∑ xs} = cons ‚âà.refl IdÀò
\end{spec}
%}}}
  %{{{ Properties of insertion and deletion for vectors
\begin{code}
  insert-cong : {n : ‚Ñï} {xs ys : Seq n} {i : Fin (suc n)} {e : Carrier}
              ‚Üí xs  ‚âà‚Çñ  ys  ‚Üí  insert xs i e  ‚âà‚Çñ  insert ys i e
  insert-cong {i = zero} xs‚âàys = cons ‚âà.refl xs‚âàys
  insert-cong {i = suc _} nil              = ‚âà‚Çñ-refl
  insert-cong {i = suc _} (cons x‚âày xs‚âàys) = cons x‚âày (insert-cong xs‚âàys)

  -- Inverse of insert
  delete : {n : ‚Ñï} {a : Level} {A : Set a} ‚Üí Vec A (suc n) ‚Üí Fin (suc n) ‚Üí Vec A n
  delete (x ‚à∑ xs) zero    = xs
  delete (x ‚à∑ []) (suc ())
  delete (x ‚à∑ _ ‚à∑ xs) (suc zero) = x ‚à∑ xs
  delete (x ‚à∑ y ‚à∑ xs) (suc (suc i)) = x ‚à∑ delete (y ‚à∑ xs) (suc i)

  delete-suc : {n : ‚Ñï} {xs : Seq (suc n)} {i : Fin (suc n)} {x : Carrier}
             ‚Üí delete (x ‚à∑ xs) (suc i)  ‚âà‚Çñ  (x ‚à∑ delete xs i)
  delete-suc {xs = x ‚à∑ xs} {zero}   =  ‚âà‚Çñ-refl
  delete-suc {xs = x ‚à∑ xs} {suc i}  =  ‚âà‚Çñ-refl

  delete-insert : {n : ‚Ñï} {xs : Seq n} {i : Fin (suc n)} {x : Carrier}
                ‚Üí delete (insert xs i x) i  ‚âà‚Çñ  xs
  delete-insert {xs = []} {zero} = ‚âà‚Çñ-refl
  delete-insert {xs = []} {suc ()}
  delete-insert {xs = x ‚à∑ xs} {zero} = ‚âà‚Çñ-refl
  delete-insert {xs = x ‚à∑ xs} {suc zero} = ‚âà‚Çñ-refl
  delete-insert {xs = x ‚à∑ xs} {suc (suc i)} {e} = goal
    where it :    delete (x ‚à∑ insert xs (suc i) e) (suc (suc i))
               ‚âà‚Çñ (x ‚à∑ delete (insert xs (suc i) e) (suc i))
          it = delete-suc

          indHyp : delete (insert xs (suc i) e) (suc i)  ‚âà‚Çñ  xs
          indHyp = delete-insert

          goal : delete (x ‚à∑ insert xs (suc i) e) (suc (suc i)) ‚âà‚Çñ (x ‚à∑ xs)
          goal = ‚âà‚Çñ-trans it (cons ‚âà.refl indHyp)

  insert-delete : {n : ‚Ñï} {xs : Seq (suc n)} {i : Fin (suc n)}
                ‚Üí insert (delete xs i) i (lookup i xs)  ‚âà‚Çñ  xs
  insert-delete {zero} {x ‚à∑ xs} {zero} = ‚âà‚Çñ-refl
  insert-delete {zero} {x ‚à∑ xs} {suc ()}
  insert-delete {suc n} {x ‚à∑ xs} {zero} = ‚âà‚Çñ-refl
  insert-delete {suc n} {x ‚à∑ xs} {suc i} = goal
    where it : delete (x ‚à∑ xs) (suc i)  ‚âà‚Çñ  (x ‚à∑ delete xs i)
          it = delete-suc

          notice :    insert (x ‚à∑ delete xs i) (suc i) (lookup i xs)
                   ‚âà‚Çñ (x ‚à∑ insert (delete xs i) i (lookup i xs))
          notice = ‚âà‚Çñ-refl  -- by definition of |insert|

          indHyp :    insert (delete xs i) i (lookup i xs)
                   ‚âà‚Çñ  xs
          indHyp = insert-delete

          goal :    insert (delete (x ‚à∑ xs) (suc i)) (suc i) (lookup i xs)
                  ‚âà‚Çñ (x ‚à∑ xs)
          goal = ‚âà‚Çñ-trans (insert-cong it) (cons ‚âà.refl indHyp) 
\end{code}
%}}}
  %{{{ ‚óà is a group action: It is an functorial in it's first argument.

\begin{code}
  ‚óà-leftId : {n : ‚Ñï} {xs : Seq n} ‚Üí Id ‚óà xs  ‚âà‚Çñ  xs
  ‚óà-leftId {zero} {[]} = ‚âà‚Çñ-refl
  ‚óà-leftId {suc n} {x ‚à∑ xs} = cons ‚âà.refl ‚óà-leftId

  -- Composition of permutations
  infix 6 _‚äô_
  _‚äô_ : {n : ‚Ñï} ‚Üí Permutation n ‚Üí Permutation n ‚Üí Permutation n
  nil ‚äô nil = nil
  cons p ps ‚äô qs  =  cons (qs at‚Ä≤ p) (ps ‚äô (qs ‚îÄ p))

  -- ‚äô-nil : {n : ‚Ñï} {ps : Permutation n} ‚Üí ps ‚äô nil  ‚â°  ps
  -- ‚äô-nil {n} {ps} = ?

{-
  -- The inversion operation is contravariant: It reverses composition.
  ‚óà-Àò : {n : ‚Ñï} {ps qs : Permutation n} ‚Üí (ps ‚äô qs)Àò  ‚âà‚Çö (qs Àò ‚äô ps Àò)
  ‚óà-Àò {.0} {nil} {nil} = ‚âà‚Çñ-refl
  ‚óà-Àò {.(suc _)} {cons p ps} {qs} = {! MA: write a test to be confident this is somewhat true.!}

  insert-‚óà : {n : ‚Ñï} {ps : Permutation n} {q : Fin (suc n)} {qs : Permutation n}
             {xs : Seq n} {x : Carrier}
           ‚Üí insert (ps ‚óà (qs ‚óà xs)) q x  ‚âà‚Çñ  (cons zero ps) ‚óà (insert (qs ‚óà xs) q x)
  insert-‚óà {n} {ps} {q} {qs} {xs} = {! MA: write a test to be confident this is somewhat true.!}

  ‚óà-compose : {n : ‚Ñï} {ps qs : Permutation n} {xs : Seq n} ‚Üí (ps ‚äô qs) ‚óà xs  ‚âà‚Çñ  ps ‚óà (qs ‚óà xs)
  ‚óà-compose {.0} {nil} {nil} {[]} = ‚âà‚Çñ-refl
  ‚óà-compose {.(suc _)} {cons zero ps} {cons q qs} {x ‚à∑ xs} = ‚âà‚Çñ-trans (insert-cong ‚óà-compose) insert-‚óà
  ‚óà-compose {.(suc _)} {cons (suc p) ps} {cons q qs} {x ‚à∑ xs} = {! MA: write a test to be confident this is somewhat true. !}

-}

\end{code}

%}}}

%}}}

Expected definition,
\begin{spec}
  data _‚âà‚Çö_ {n : ‚Ñï} (xs ys : Seq n) : Set (c ‚äç ‚Ñì) where
    yes : (p : Permutation n) ‚Üí p ‚óà xs ‚âà‚Çñ ys ‚Üí xs ‚âà‚Çö ys
\end{spec}

However this does not fit in with our needs in |Bag.lagda|, so we work with a bit of
an awkward definition. \edcomm{MA}{Perhaps we could have a transform between the two forms?}

\begin{spec}
  List = Œ£ n ‚à∂ ‚Ñï ‚Ä¢ Seq n

  data _‚âà‚Çö‚Çó_ : (x y : List) ‚Üí Set (c ‚äç ‚Ñì) where
    yes : {n : ‚Ñï} {xs ys : Seq n} (p : Permutation n) ‚Üí p ‚óà xs ‚âà‚Çñ ys ‚Üí (n , xs) ‚âà‚Çö‚Çó (n , ys)

  to-awkward : {m n : ‚Ñï} {xs : Seq m} {ys : Seq n} ‚Üí m ‚â° n ‚Üí xs ‚âà‚Çö ys ‚Üí (n , xs) ‚âà‚Çö‚Çó (m , ys)
  to-awkward ‚â°.refl (yes p p‚óàxs‚âàys) = yes p p‚óàxs‚âàys

  postulate ‚âà‚Çö-refl :  {n : ‚Ñï}{xs       : Seq n} ‚Üí xs ‚âà‚Çö xs
  postulate ‚âà‚Çö-sym :   {n : ‚Ñï}{xs ys    : Seq n} ‚Üí xs ‚âà‚Çö ys ‚Üí ys ‚âà‚Çö xs
  postulate ‚âà‚Çö-trans : {n : ‚Ñï}{xs ys zs : Seq n} ‚Üí xs ‚âà‚Çö ys ‚Üí ys ‚âà‚Çö zs ‚Üí xs ‚âà‚Çö zs

  ‚âà‚Çö-isEquivalence : {n : ‚Ñï} ‚Üí IsEquivalence (_‚âà‚Çö_ {n})
  ‚âà‚Çö-isEquivalence = record { refl = ‚âà‚Çö-refl ; sym = ‚âà‚Çö-sym ; trans = ‚âà‚Çö-trans }

  ‚âà‚Çö‚Çó-isEquivalence : IsEquivalence _‚âà‚Çö‚Çó_
  ‚âà‚Çö‚Çó-isEquivalence = record { refl = to-awkward ‚âà‚Çö-refl ; sym = {!to-awkward ‚àò‚ÇÄ ?!} ; trans = {!!} }

  Œµ : List
  Œµ = (0 , [])

  _‚äï_ : List ‚Üí List ‚Üí List
  (_ , xs) ‚äï (_ , ys) = (_ , xs ++ ys)

  -- Strangely properties about Vec catenation are not in the standard library

  ‚äï-left-unit : ‚àÄ ys ‚Üí (Œµ ‚äï ys) ‚âà‚Çö‚Çó ys
  ‚äï-left-unit ys = ‚âà‚Çö‚Çó-refl

--  ‚âà‚Çö‚Çó-pair : {m n : ‚Ñï} {xs : Seq m} {ys : Seq n} ‚Üí m ‚â° n ‚Üí s ‚âà‚Çö‚Çó t ‚Üí (m , xc

  ‚äï-right-unit : ‚àÄ ys ‚Üí (ys ‚äï Œµ) ‚âà‚Çö‚Çó ys
  ‚äï-right-unit (.0 , []) = ‚âà‚Çö‚Çó-refl
  ‚äï-right-unit (.(suc _) , x ‚à∑ proj‚ÇÑ) = {!‚âà‚Çö‚Çó-refl!}
\end{spec}

\begin{code}
  open import Data.List
  Seq‚àû = List Carrier

  record _‚âà‚Çö_ (xs ys : List Carrier) : Set (c ‚äç ‚Ñì) where
    len‚ÇÅ : ‚Ñï
    len‚ÇÅ = length xs

    len‚ÇÇ : ‚Ñï
    len‚ÇÇ = length ys

    field
      lengths : len‚ÇÇ ‚â° len‚ÇÅ
      witness : Permutation len‚ÇÅ
      proof   : witness ‚óà fromList xs ‚âà‚Çñ ‚â°.subst Seq lengths (fromList ys)

  ‚âà‚Çö-reflexive : {xs ys : Seq‚àû} ‚Üí xs ‚â° ys ‚Üí xs ‚âà‚Çö ys
  ‚âà‚Çö-reflexive ‚â°.refl = record { lengths = ‚â°.refl ; witness = Id ; proof = ‚óà-leftId   }

  ‚âà‚Çö-refl :  {xs : Seq‚àû} ‚Üí xs ‚âà‚Çö xs
  ‚âà‚Çö-refl = ‚âà‚Çö-reflexive ‚â°.refl

  postulate ‚âà‚Çö-sym :   {xs ys    : Seq‚àû} ‚Üí xs ‚âà‚Çö ys ‚Üí ys ‚âà‚Çö xs
  postulate ‚âà‚Çö-trans : {xs ys zs : Seq‚àû} ‚Üí xs ‚âà‚Çö ys ‚Üí ys ‚âà‚Çö zs ‚Üí xs ‚âà‚Çö zs

  ‚âà‚Çö-isEquivalence : IsEquivalence _‚âà‚Çö_
  ‚âà‚Çö-isEquivalence = record { refl = ‚âà‚Çö-refl ; sym = ‚âà‚Çö-sym ; trans = ‚âà‚Çö-trans }

  singleton-‚âà : {x y : Carrier} ‚Üí x ‚âà y ‚Üí (x ‚à∑ []) ‚âà‚Çö (y ‚à∑ [])
  singleton-‚âà x‚âày = record { lengths = ‚â°.refl ; witness = Id ; proof = VecEquality.cons x‚âày nil }
\end{code}


%{{{ approach via vectors rather than lists

\begin{code}
module Lemmas {l c : Level} {ùíÆ : Setoid c l} (ùíû : CommMonoid ùíÆ) where

  open CommMonoid ùíû
  open IsCommutativeMonoid isCommMonoid -- \edcomm{MA}{The field name really oughtn't be abbreviated!}
  
  open Setoid ùíÆ
  
  open VecEquality ùíÆ
  -- module ‚âà = Setoid ùíÆ

  open Permutations ùíÆ

  -- from CommMonoid.CommMonoid
  -- open Setoid ùíÆ using () renaming (Carrier to X‚ÇÄ)
  -- postulate e            : X‚ÇÄ
  -- postulate _*_          : X‚ÇÄ ‚Üí X‚ÇÄ ‚Üí X‚ÇÄ  -- \edcomm{MA}{Why is this `e` but above is `¬∑`?}
  -- _‚ü®‚âà‚ü©_ = ‚âà.trans
  -- infix -666 eq-in
  -- eq-in = ‚âà._‚âà_
  -- syntax eq-in M x y  =  x ‚âà y ‚à∂ M   -- ghost colon
  -- import Algebra.FunctionProperties as AFP
  -- open AFP ‚âà._‚âà_
  -- postulate  _‚ü®‚àô‚ü©_        : Congruent‚ÇÇ _*_
  -- postulate assoc       : Associative _*_
  -- postulate     comm        : Commutative _*_

  open import Data.List
  open import Data.Nat  hiding (fold ; _*_)
  open import Data.Fin  hiding (_+_ ; fold ; _‚â§_)  
\end{code}


\begin{code}  
  -- fold is a setoid homomorphism

  fold : Seq‚àû ‚Üí Carrier
  fold = foldr _*_ e

  open import Data.Vec using (fromList)

  fold-cong : {xs ys : Seq‚àû} ‚Üí xs ‚âà‚Çö ys ‚Üí fold xs ‚âà fold ys
  fold-cong {[]} {[]} record { lengths = ‚â°.refl ; witness = witness ; proof = proof } = {!!}
  fold-cong {[]} {x ‚à∑ ys} record { lengths = () ; witness = witness ; proof = proof }
  fold-cong {x ‚à∑ xs} {ys} record { lengths = lengths ; witness = witness ; proof = proof } = {!!}

\end{code}
  fold-cong : {xs ys : Seq‚àû} ‚Üí fromList xs ‚âà‚Çñ fromList ys ‚Üí fold xs ‚âà fold ys
  fold-cong {_} {[]} {.[]} nil = refl
  fold-cong {_} {x ‚à∑ xs} {y ‚à∑ ys} (cons x‚âày xs‚âàys) = x‚âày ‚ü®‚àô‚ü© fold-cong xs‚âàys
  -- commutativity is not used here and so this result is valid for non-commutative monoids as well.

  open Permutations ùíÆ
  
  data _‚âà·µ•_ {n : ‚Ñï} (xs : Seq n) (ys : Seq n) : Set (c ‚äç l) where
    yes : (p : Permutation n) ‚Üí p ‚óà xs ‚âà‚Çñ ys ‚Üí xs ‚âà·µ• ys

  open import Relation.Binary.SetoidReasoning

  -- commutativity here!
  proposition‚ÇÑ : {n : ‚Ñï} {zs : Seq n} {x y : Carrier}
               ‚Üí fold (x ‚à∑ y ‚à∑ zs) ‚âà fold (y ‚à∑ x ‚à∑ zs)
  proposition‚ÇÑ {n} {zs} {x} {y} = begin‚ü® ùíÆ ‚ü©
      fold (x ‚à∑ y ‚à∑ zs)
    ‚âàÀò‚ü® assoc _ _ _ ‚ü©
      (x * y) * fold zs
    ‚âà‚ü® comm _ _ ‚ü®‚àô‚ü© refl ‚ü©
      (y * x) * fold zs
    ‚âà‚ü® assoc _ _ _ ‚ü©
      fold (y ‚à∑ x ‚à∑ zs)
    ‚àé

  proposition‚ÇÉ : {n : ‚Ñï} {xs : Seq n} {i : Fin (suc n)} {x y : Carrier}
               ‚Üí fold (x ‚à∑ y ‚à∑ xs) ‚âà fold (y ‚à∑ insert xs i x)
  proposition‚ÇÉ {.0} {[]} {zero} =  proposition‚ÇÑ 
  proposition‚ÇÉ {.0} {[]} {suc ()}
  proposition‚ÇÉ {.(suc _)} {x ‚à∑ xs} {zero} = proposition‚ÇÑ 
  proposition‚ÇÉ {.(suc _)} {hd ‚à∑ xs} {suc i} {x} {y} = begin‚ü® ùíÆ ‚ü©
      fold (x ‚à∑ y ‚à∑ hd ‚à∑ xs)
    ‚âà‚ü® proposition‚ÇÑ ‚ü©
      fold (y ‚à∑ x ‚à∑ hd ‚à∑ xs)
    ‚â°‚ü® ‚â°.refl ‚ü©
      y * fold (x ‚à∑ hd ‚à∑ xs)
    ‚âà‚ü® refl ‚ü®‚àô‚ü© proposition‚ÇÉ ‚ü©
      y * fold (hd ‚à∑ insert xs i x)
    ‚â°‚ü® ‚â°.refl ‚ü©
      fold (y ‚à∑ hd ‚à∑ insert xs i x)
    ‚àé
  
  proposition‚ÇÇ : {n : ‚Ñï} {xs : Seq n} {i : Fin (suc n)} {x : Carrier}
               ‚Üí fold (x ‚à∑ xs) ‚âà fold (insert xs i x)
  proposition‚ÇÇ {.0} {[]} {zero} = refl
  proposition‚ÇÇ {.0} {[]} {suc ()}
  proposition‚ÇÇ {.(suc _)} {y ‚à∑ xs} {zero} = refl
  proposition‚ÇÇ {.(suc _)} {y ‚à∑ xs} {suc i} = proposition‚ÇÉ

  open import Relation.Binary.PropositionalEquality using (inspect; [_])

  proposition‚ÇÅ : {n : ‚Ñï} {xs : Seq n} {p : Permutation n} ‚Üí fold xs ‚âà fold (p ‚óà xs) 
  proposition‚ÇÅ {.0} {[]} {nil} = refl
  proposition‚ÇÅ {.(suc _)} {x ‚à∑ xs} {cons zero ps} = refl ‚ü®‚àô‚ü© proposition‚ÇÅ
  proposition‚ÇÅ {.(suc _)} {x ‚à∑ xs} {cons (suc p) ps} with ps ‚óà xs | inspect (_‚óà_ ps) xs
  proposition‚ÇÅ {.(suc 0)} {x ‚à∑ xs} {cons (suc ()) ps} | [] | _
  proposition‚ÇÅ {.(suc (suc _))} {x ‚à∑ xs} {cons (suc p) ps} | x‚Ä≤ ‚à∑ xs‚Ä≤ | [ ps-on-xs‚âàxs‚Ä≤ ] = begin‚ü® ùíÆ ‚ü©
      x * fold xs
    ‚âà‚ü® refl ‚ü®‚àô‚ü© proposition‚ÇÅ ‚ü©
      x * fold (ps ‚óà xs)
    ‚â°‚ü® ‚â°.cong (Œª zs ‚Üí x * fold zs) ps-on-xs‚âàxs‚Ä≤ ‚ü©
      x * fold (x‚Ä≤ ‚à∑ xs‚Ä≤)
    ‚â°‚ü® ‚â°.refl ‚ü©
      fold (x ‚à∑ x‚Ä≤ ‚à∑ xs‚Ä≤)
    ‚âà‚ü® proposition‚ÇÑ ‚ü©
      fold (x‚Ä≤ ‚à∑ x ‚à∑ xs‚Ä≤)
    ‚â°‚ü® ‚â°.refl ‚ü©
      x‚Ä≤ * fold (x ‚à∑ xs‚Ä≤)
    ‚âà‚ü® refl ‚ü®‚àô‚ü© proposition‚ÇÇ ‚ü©
      x‚Ä≤ * fold (insert xs‚Ä≤ p x)
    ‚àé

  -- This is essentially |Multiset.fold-permute|, the pesky-hole from the summer.
  proposition‚ÇÄ : {n : ‚Ñï} {xs ys : Seq n} ‚Üí xs ‚âà·µ• ys ‚Üí fold xs ‚âà fold ys 
  proposition‚ÇÄ (yes p p-on-xs‚âàys) = trans proposition‚ÇÅ (fold-cong p-on-xs‚âàys)


%{{{ Vector based approach, it works:
\begin{spec}  
  -- fold is a setoid homomorphism

  fold : {n : ‚Ñï} ‚Üí Seq n ‚Üí Carrier
  fold = foldr (Œª _ ‚Üí Carrier) _*_ e

  fold-cong : {n : ‚Ñï} {xs ys : Seq n} ‚Üí xs ‚âà‚Çñ ys ‚Üí fold xs ‚âà fold ys
  fold-cong {_} {[]} {.[]} nil = refl
  fold-cong {_} {x ‚à∑ xs} {y ‚à∑ ys} (cons x‚âày xs‚âàys) = x‚âày ‚ü®‚àô‚ü© fold-cong xs‚âàys
  -- commutativity is not used here and so this result is valid for non-commutative monoids as well.

  open Permutations ùíÆ
  
  data _‚âà·µ•_ {n : ‚Ñï} (xs : Seq n) (ys : Seq n) : Set (c ‚äç l) where
    yes : (p : Permutation n) ‚Üí p ‚óà xs ‚âà‚Çñ ys ‚Üí xs ‚âà·µ• ys

  open import Relation.Binary.SetoidReasoning

  -- commutativity here!
  proposition‚ÇÑ : {n : ‚Ñï} {zs : Seq n} {x y : Carrier}
               ‚Üí fold (x ‚à∑ y ‚à∑ zs) ‚âà fold (y ‚à∑ x ‚à∑ zs)
  proposition‚ÇÑ {n} {zs} {x} {y} = begin‚ü® ùíÆ ‚ü©
      fold (x ‚à∑ y ‚à∑ zs)
    ‚âàÀò‚ü® assoc _ _ _ ‚ü©
      (x * y) * fold zs
    ‚âà‚ü® comm _ _ ‚ü®‚àô‚ü© refl ‚ü©
      (y * x) * fold zs
    ‚âà‚ü® assoc _ _ _ ‚ü©
      fold (y ‚à∑ x ‚à∑ zs)
    ‚àé

  proposition‚ÇÉ : {n : ‚Ñï} {xs : Seq n} {i : Fin (suc n)} {x y : Carrier}
               ‚Üí fold (x ‚à∑ y ‚à∑ xs) ‚âà fold (y ‚à∑ insert xs i x)
  proposition‚ÇÉ {.0} {[]} {zero} =  proposition‚ÇÑ 
  proposition‚ÇÉ {.0} {[]} {suc ()}
  proposition‚ÇÉ {.(suc _)} {x ‚à∑ xs} {zero} = proposition‚ÇÑ 
  proposition‚ÇÉ {.(suc _)} {hd ‚à∑ xs} {suc i} {x} {y} = begin‚ü® ùíÆ ‚ü©
      fold (x ‚à∑ y ‚à∑ hd ‚à∑ xs)
    ‚âà‚ü® proposition‚ÇÑ ‚ü©
      fold (y ‚à∑ x ‚à∑ hd ‚à∑ xs)
    ‚â°‚ü® ‚â°.refl ‚ü©
      y * fold (x ‚à∑ hd ‚à∑ xs)
    ‚âà‚ü® refl ‚ü®‚àô‚ü© proposition‚ÇÉ ‚ü©
      y * fold (hd ‚à∑ insert xs i x)
    ‚â°‚ü® ‚â°.refl ‚ü©
      fold (y ‚à∑ hd ‚à∑ insert xs i x)
    ‚àé
  
  proposition‚ÇÇ : {n : ‚Ñï} {xs : Seq n} {i : Fin (suc n)} {x : Carrier}
               ‚Üí fold (x ‚à∑ xs) ‚âà fold (insert xs i x)
  proposition‚ÇÇ {.0} {[]} {zero} = refl
  proposition‚ÇÇ {.0} {[]} {suc ()}
  proposition‚ÇÇ {.(suc _)} {y ‚à∑ xs} {zero} = refl
  proposition‚ÇÇ {.(suc _)} {y ‚à∑ xs} {suc i} = proposition‚ÇÉ

  open import Relation.Binary.PropositionalEquality using (inspect; [_])

  proposition‚ÇÅ : {n : ‚Ñï} {xs : Seq n} {p : Permutation n} ‚Üí fold xs ‚âà fold (p ‚óà xs) 
  proposition‚ÇÅ {.0} {[]} {nil} = refl
  proposition‚ÇÅ {.(suc _)} {x ‚à∑ xs} {cons zero ps} = refl ‚ü®‚àô‚ü© proposition‚ÇÅ
  proposition‚ÇÅ {.(suc _)} {x ‚à∑ xs} {cons (suc p) ps} with ps ‚óà xs | inspect (_‚óà_ ps) xs
  proposition‚ÇÅ {.(suc 0)} {x ‚à∑ xs} {cons (suc ()) ps} | [] | _
  proposition‚ÇÅ {.(suc (suc _))} {x ‚à∑ xs} {cons (suc p) ps} | x‚Ä≤ ‚à∑ xs‚Ä≤ | [ ps-on-xs‚âàxs‚Ä≤ ] = begin‚ü® ùíÆ ‚ü©
      x * fold xs
    ‚âà‚ü® refl ‚ü®‚àô‚ü© proposition‚ÇÅ ‚ü©
      x * fold (ps ‚óà xs)
    ‚â°‚ü® ‚â°.cong (Œª zs ‚Üí x * fold zs) ps-on-xs‚âàxs‚Ä≤ ‚ü©
      x * fold (x‚Ä≤ ‚à∑ xs‚Ä≤)
    ‚â°‚ü® ‚â°.refl ‚ü©
      fold (x ‚à∑ x‚Ä≤ ‚à∑ xs‚Ä≤)
    ‚âà‚ü® proposition‚ÇÑ ‚ü©
      fold (x‚Ä≤ ‚à∑ x ‚à∑ xs‚Ä≤)
    ‚â°‚ü® ‚â°.refl ‚ü©
      x‚Ä≤ * fold (x ‚à∑ xs‚Ä≤)
    ‚âà‚ü® refl ‚ü®‚àô‚ü© proposition‚ÇÇ ‚ü©
      x‚Ä≤ * fold (insert xs‚Ä≤ p x)
    ‚àé

  -- This is essentially |Multiset.fold-permute|, the pesky-hole from the summer.
  proposition‚ÇÄ : {n : ‚Ñï} {xs ys : Seq n} ‚Üí xs ‚âà·µ• ys ‚Üí fold xs ‚âà fold ys 
  proposition‚ÇÄ (yes p p-on-xs‚âàys) = trans proposition‚ÇÅ (fold-cong p-on-xs‚âàys)
\end{spec}
%}}}

%}}}

%{{{ attempting to connect the above with work in BagEq
\begin{spec}
  open BagEq ùíÆ
  _‚âà·µ•·µ•_ : {n : ‚Ñï} ‚Üí Seq n ‚Üí Seq n ‚Üí Set (c ‚äç l)
  _‚âà·µ•·µ•_ = Œª xs ys ‚Üí toList xs ‚áî toList ys

  open Locations ùíÆ
  -- no.
  bridge‚ÇÅ : {n : ‚Ñï} {xs ys : Seq n} {a b : Carrier} ‚Üí (a ‚à∑ xs) ‚âà·µ•·µ• (b ‚à∑ ys) ‚Üí a ‚âà b ‚äé a ‚àà‚ÇÄ toList ys
  bridge‚ÇÅ {.0} {[]} {[]} eq = {!!}
  bridge‚ÇÅ {.(suc _)} {x ‚à∑ xs} {x‚ÇÅ ‚à∑ ys} eq = {!!}

  bridge : {n : ‚Ñï} {xs ys : Seq n} ‚Üí xs ‚âà·µ•·µ• ys ‚Üí xs ‚âà·µ• ys
  bridge {.0} {[]} {[]} eq = yes nil nil
  bridge {.(suc _)} {x ‚à∑ xs} {y ‚à∑ ys} eq = {!This may require decidable equality on elements.!}
\end{spec}
%}}}

%{{{ Ignore: Lists approach requires some transformations between with Fin's
\begin{spec}
open import Algebra   using (CommutativeMonoid)
module Lemmas‚Ä≤ {l c : Level} {ùíû : CommutativeMonoid c l} where

  open CommutativeMonoid ùíû
  open import Relation.Binary.SetoidReasoning -- renaming (_‚àé to _‚ñ†)

  open import Data.List     using (List; []; _++_; _‚à∑_; foldr; length)  renaming (map to mapL)
  open import Data.List.Properties using (map-++-commute; map-id; map-compose)

  open import Data.Nat hiding (fold)
  open import Data.Fin hiding (_+_ ; fold)

  -- Sequences
  Seq = List Carrier

  -- `k`omponent-wise equality on sequences ;; MA: Subscript `c` not directly available.
  data _‚âà‚Çñ_ : Seq ‚Üí Seq ‚Üí Set (c ‚äç l) where
    nil  : [] ‚âà‚Çñ []
    cons : {x y : Carrier} {xs ys : Seq} ‚Üí x ‚âà y ‚Üí xs ‚âà‚Çñ ys ‚Üí (x ‚à∑ xs) ‚âà‚Çñ (y ‚à∑ ys)

  -- MA: It is a simple matter to show that this is an equivalence relation. TODO.
  
  -- fold is a setoid homomorphism

  fold : Seq ‚Üí Carrier
  fold = foldr _‚àô_ Œµ

  fold-cong : {xs ys : Seq} ‚Üí xs ‚âà‚Çñ ys ‚Üí fold xs ‚âà fold ys
  fold-cong {[]} {.[]} nil = refl
  fold-cong {x ‚à∑ xs} {y ‚à∑ ys} (cons x‚âày xs‚âàys) = begin‚ü® setoid ‚ü©
      fold (x ‚à∑ xs)
    ‚â°‚ü® ‚â°.refl ‚ü©
      x ‚àô fold xs
    ‚âà‚ü® ‚àô-cong x‚âày (fold-cong xs‚âàys) ‚ü©
      y ‚àô fold ys
    ‚â°‚ü® ‚â°.refl ‚ü©
      fold (y ‚à∑ ys)
    ‚àé
  -- commutativity is not used here and so this result is valid for non-commutative monoids as well.

  -- from copumkin's library
  data Permutation : ‚Ñï ‚Üí Set where
    nil  : Permutation 0
    cons : {n : ‚Ñï} (p : Fin (1 + n)) (ps : Permutation n) ‚Üí Permutation (1 + n)

  -- insert : ‚àÄ {n} {a} {A : Set a} ‚Üí Vec A n ‚Üí Fin (1 + n) ‚Üí A ‚Üí Vec A (1 + n)
  insert : (xs : Seq) ‚Üí Fin (1 + length xs) ‚Üí Carrier ‚Üí Seq
  insert xs zero a = a ‚à∑ xs
  insert [] (suc ()) a
  insert (x ‚à∑ xs) (suc i) a = x ‚à∑ insert xs i a

  -- permute : ‚àÄ {n} {a} {A : Set a} ‚Üí Permutation n ‚Üí Vec A n ‚Üí Vec A n
  mutual
  
    permute : (xs : Seq) ‚Üí Permutation (length xs) ‚Üí Seq
    permute [] nil = []
    permute (x ‚à∑ xs) (cons p ps)  = insert (permute xs ps) (cast p) x
    --
    -- Note that we switch the order as compared to copumkin since we're using lists.

    cast : {xs : Seq} {p : Permutation (length xs)}
         ‚Üí Fin (1 + length xs) ‚Üí Fin (1 + length (permute xs p))
    cast {[]} {nil} i = i
    cast {x ‚à∑ xs} {cons p p‚ÇÅ} zero = zero
    cast {x ‚à∑ xs} {cons p p‚ÇÅ} (suc i) = {!!} -- suc (insert-cast {!!}) -- (insert-cast {!!})

    insert-cast : {xs : Seq} {i : Fin (1 + length xs)} {x : Carrier}
                  {ps : Permutation (length xs)}
              ‚Üí Fin (length xs) ‚Üí Fin (length (insert (permute xs ps) (cast i) x))
    insert-cast = {!!}
\end{spec}
%}}}

% Quick Folding Instructions:
% C-c C-s :: show/unfold region
% C-c C-h :: hide/fold region
% C-c C-w :: whole file fold
% C-c C-o :: whole file unfold
%
% Local Variables:
% folded-file: t
% eval: (fold-set-marks "%{{{ " "%}}}")
% eval: (fold-whole-buffer)
% fold-internal-margins: 0
% end:
