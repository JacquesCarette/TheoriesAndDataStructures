\documentclass[serif,mathserif,professionalfont,10pt]{beamer}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{etex}
\usepackage{graphicx}
\usepackage{textgreek}

\usepackage{amssymb}

\usepackage{color}
\definecolor{grey}{gray}{0.6}

\beamertemplatenavigationsymbolsempty
\usetheme{Boadilla}
\usecolortheme{beaver}

\makeatletter
\def\mkcommand#1{\expandafter\gdef\csname #1\endcsname}
\makeatother

\def\module#1{\message{#1}\section{#1}\sectlabel{#1}}

\newenvironment{ModuleHead}{\par\begingroup\tiny}{\endgroup\par\medskip}

\DeclareUnicodeCharacter{7472}{\ensuremath{^\mathsf{D}}} % MODIFIER LETTER CAPITAL D
\DeclareUnicodeCharacter{9723}{\ensuremath{\square}} % WHITE MEDIUM SQUARE
\DeclareUnicodeCharacter{119920}{\ensuremath{\mathbf{I}}} % MATHEMATICAL BOLD ITALIC CAPITAL I
\DeclareUnicodeCharacter{119991}{\ensuremath{_\mathsf{B}}} % MATHEMATICAL SCRIPT SMALL B
\DeclareUnicodeCharacter{120008}{\ensuremath{_\mathsf{S}}} % MATHEMATICAL SCRIPT SMALL S
\DeclareUnicodeCharacter{120001}{\ensuremath{_\mathsf{L}}} % MATHEMATICAL SCRIPT SMALL L
\DeclareUnicodeCharacter{119997}{\ensuremath{_\mathsf{H}}} % MATHEMATICAL SCRIPT SMALL H
\DeclareUnicodeCharacter{8348}{\ensuremath{_\mathsf{t}}} % MATHEMATICAL SCRIPT SMALL T
\DeclareUnicodeCharacter{8339}{\ensuremath{_\mathsf{x}}} % MATHEMATICAL SCRIPT SMALL X
\DeclareUnicodeCharacter{119925}{\ensuremath{\mathcal{N}}} % MATHEMATICAL BOLD ITALIC CAPITAL N
\DeclareUnicodeCharacter{119924}{\ensuremath{\mathcal{M}}} % MATHEMATICAL BOLD ITALIC CAPITAL M
\DeclareUnicodeCharacter{7484}{\ensuremath{\mathsf{O}}} % MODIFIER LETTER CAPITAL O
\DeclareUnicodeCharacter{9678}{\ensuremath{\mathsf{BULLSEYE}}} % BULLSEYE
\DeclareUnicodeCharacter{8667}{\ensuremath{\Rrightarrow}} % rightwards triple arrow
\DeclareUnicodeCharacter{8255}{\ensuremath{\smile}} % undertie, subscript-converse
\DeclareUnicodeCharacter{8265}{\ensuremath{! \! ? }} % exclamation question mark
\DeclareUnicodeCharacter{9632}{\ensuremath{ \square }} % black square
\DeclareUnicodeCharacter{9679}{\ensuremath{ \boldsymbol{\cdot} }} % black circle
\DeclareUnicodeCharacter{9675}{\ensuremath{ \boldsymbol{\circ} }} % white circle

\title{A tale of theories and data-structures}
\author[Carette, Al-hassy, Kahl]{Jacques Carette, Musa Al-hassy, Wolfram Kahl}
\institute[McMaster]{McMaster University, Hamilton}

\begin{document}

\frame{\titlepage}

% Start to fill the slides with verbiage that needs to evolve into something
% slide-like, with few words and many illustrations. But the words embody the
% plan and, to a certain extent, the verbal delivery of parts of the story.
\begin{frame}
\frametitle{Lists and Monoids}
Lists and Monoids are pervasive in functional programming.
They are related. A |List| is really a |Free Monoid|. What does that really mean?
Can it be explained more simply? One explanation is that |List| (with its |map| and
|fold| operations) is the \emph{language of monoids}. In other words, |List| is the
canonical term syntax for ``computing with monoids''.
\end{frame}

\begin{frame}
\frametitle{A formal relation}
The free monoid functor is ``the'' left adjoint to the forgetful functor from
the category (monoids, homomorphisms) to the category (types, functions). Not Set.

%
% What is the difference between ``the category (types, functions)'' and ``Set''?
%

Why on earth would we care about that? Let's see.

% Go to Agda code.  Show definitions of
% Monoid. Monoid Homomorphism. Forgetful functor.
% Then definition of Free and the Adjunction.
\end{frame}

\begin{frame}
\frametitle{Non-categorical version}
The requirements roughly translate to\\
Monoid:
\begin{itemize}
\item Need a \emph{container} $C$ of $α$
\item with a distinguished container $ε$ devoid of $α$'s
\item a binary operation $*$ that puts two containers together
\item such that $ε$ is a left/right unit for $*$
\end{itemize}
Functor:
\begin{itemize}
\item a way to apply a $(α → β)$ function to a $C\, α$ to get a $C \, β$
\item which plays well with $\mathsf{id}, ∘, ≡$ and $*$
\end{itemize}
Adjunction:
\begin{itemize}
\item singleton
\item foldr (over arbitrary Monoid)
\item foldr and singleton ``play well'' with each other
\end{itemize}
Bonus:
\begin{itemize}
\item Induction principle
\end{itemize}
\end{frame}
% Notice how I never said ``Monad'' ?
%
% Monads ≅ closure operators
%

\begin{frame}
\frametitle{The real tale}
Given an arbitrary type $A$ : \\ \vspace*{4mm}
\begin{tabular}{lll}
\textbf{Theory} & Free \textbf{Structure} & CoFree \\ \hline
Carrier & $Identity\, A$ & \\
Pointed & $Maybe\, A$ & \\ \hline
Unary & ℕ × A &  \\
Involutive & $A ⊎ A$ & A × A \\ \hline
Magma & $Tree\, A$ &  \\
Semigroup & $NEList\, A$ & \\ \hline
Monoid & $List\, A$ & \\
Left Unital Semigroup & List A × ℕ & \\
Right Unital Semigroup & ℕ × List A & \\ \hline
\end{tabular}\\ \vspace*{4mm}
\pause
What is the ``Free Structure''? It is the
\textbf{Normal form term language} associated to the theory.\\
\end{frame}

\begin{frame}
\frametitle{Benefits}
Benefits of the formal approach:
\begin{itemize}
\item Obvious: dispell silly conjectures/errors
\item fold (aka the counit)
\item induction
\end{itemize} \vspace*{4mm}
\pause
Example: counit for Involutive is ...
\end{frame}

\begin{frame}
\frametitle{Extending the tale}
Given an arbitrary type A : \\ \vspace*{4mm}
\begin{tabular}{lll}
\textbf{Theory} & Free \textbf{Structure} & CoFree \\ \hline
Carrier & Identity A & \\
Pointed & Maybe A & \\ \hline
Unary & ℕ × A &  \\
Involutive & A ⊎ A & A × A \\ \hline
Magma & Tree A &  \\
Semigroup & NEList A & \\ \hline
Monoid & List A & \\
Left Unital Semigroup & List A × ℕ & \\
Right Unital Semigroup & ℕ × List A & \\ \hline
Commutative Monoid & ? & \\
Group & ? & \\
Abelian Group & ? & \\
Idempotent Commutative Monoid & ? & \\
\end{tabular}
\end{frame}

\begin{frame}
\frametitle{Bag and Commutative Monoid}
\begin{definition}
A \emph{Bag} (over a type A) is an unordered finite collection
of elements of A.
\end{definition}
\pause
Implementation?
\begin{itemize}
\item<2-> Inductive type
\begin{itemize}
\item<3-> ordered
\end{itemize}
\item<4-> $A \rightarrow \mathbb{N}$
\begin{itemize}
\item<5-> not finite support
\end{itemize}
\item<6-> $A \rightarrow \mathbb{N}$ plus finite support
\begin{itemize}
\item<7-> ``finite support'' is hard to say constructively
\item<8-> summing over all elements of $A$ is even harder
\item<9-> can build a decidable equiv. relation on $A$ from $A \rightarrow \mathbb{N}$
\end{itemize}
\item<10-> $\texttt{List}\ A$ up to bag-equality (aka permutations)
\begin{itemize}
\item<11-> almost works!
\item<12-> Commutative Monoid uses $\equiv$
\end{itemize}
\end{itemize}
\begin{theorem}<13->There is no \emph{Bag} over an arbitrary type (in MLTT).
\end{theorem}
\end{frame}

\begin{frame}
\frametitle{Change the question!}
\begin{definition}
A \emph{DBag} over a type A with decidable equality is an unordered
collection of elements of A.
\end{definition}
\pause
\begin{definition}
A \emph{Bag} over a Setoid A is an unordered
collection of elements of the carrier of A.
\end{definition}
\pause
boo
\end{frame}
\end{document}
